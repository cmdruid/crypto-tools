!function(t,e,n){"use strict";function r(t){var e=Object.create(null);return t&&Object.keys(t).forEach((function(n){if("default"!==n){var r=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(e,n,r.get?r:{enumerable:!0,get:function(){return t[n]}})}})),e.default=t,Object.freeze(e)}var i=r(e),o=r(n);const s="qpzry9x8gf2tvdw0s3jn54khce6mua7l",a=[996825010,642813549,513874426,1027748829,705979059],c="bech32",f="bech32m";function u(t){switch(t){case c:return 1;case f:return 734539939;default:throw new Error(`Unrecognized encoding: ${t}`)}}function h(t){let e=1;for(let n=0;n<t.length;++n){const r=e>>25;e=(33554431&e)<<5^t[n];for(let t=0;t<5;++t)(r>>t&1)>0&&(e^=a[t])}return e}function l(t){const e=[];let n;for(n=0;n<t.length;++n)e.push(t.charCodeAt(n)>>5);for(e.push(0),n=0;n<t.length;++n)e.push(31&t.charCodeAt(n));return e}function d(t,e,n,r=!0){const i=[];let o=0,s=0;const a=(1<<n)-1,c=(1<<e+n-1)-1;for(const r of t){if(r<0||r>>e>0)return[];for(o=(o<<e|r)&c,s+=e;s>=n;)s-=n,i.push(o>>s&a)}if(r)s>0&&i.push(o<<n-s&a);else if(s>=e||(o<<n-s&a)>0)return[];return i}function y(t,e,n){const r=e.concat(function(t,e,n){const r=h(l(t).concat(e).concat([0,0,0,0,0,0]))^u(n),i=[];for(let t=0;t<6;++t)i.push(r>>5*(5-t)&31);return i}(t,e,n));let i=t+"1";for(let t=0;t<r.length;++t)i+=s.charAt(r[t]);return i}function g(t,e){const n=e>0?"bech32m":"bech32";if(!function(t){let e,n,r=!1,i=!1;for(e=0;e<t.length;++e){if(n=t.charCodeAt(e),n<33||n>126)return!1;n>=97&&n<=122&&(r=!0),n>=65&&n<=90&&(i=!0)}return!(r&&i)}(t))return{hrp:null,data:[255]};if(!function(t){const e=t.lastIndexOf("1");return!(e<1||e+7>t.length||t.length>90)}(t=t.toLowerCase()))return{hrp:null,data:[255]};const r=[],i=t.lastIndexOf("1"),o=t.substring(0,i);for(let e=i+1;e<t.length;++e){const n=s.indexOf(t.charAt(e));if(-1===n)return{hrp:null,data:[255]};r.push(n)}return function(t,e,n){return h(l(t).concat(e))===u(n)}(o,r,n)?{hrp:o,data:r.slice(0,r.length-6)}:{hrp:null,data:[255]}}function w(t,e=0){const n=t.split("1",1)[0],{hrp:r,data:i}=g(t,e),o=d(i.slice(1),5,8,!1),s=o.length;switch(!0){case n!==r:throw new Error("Returned hrp string is invalid.");case null===o||s<2||s>40:throw new Error("Decoded string is invalid or out of spec.");case i[0]>16:throw new Error("Returned version bit is out of range.");case 0===i[0]&&20!==s&&32!==s:throw new Error("Decoded string does not match version 0 spec.");case 0===i[0]&&0!==e:case 0!==i[0]&&1!==e:throw new Error("Decoded version bit does not match.");default:return Uint8Array.from(o)}}const p={encode:function(t,e="bch",n=0){const r=y(e,[n,...d([...t],8,5)],n>0?"bech32m":"bech32");return w(r,n),r},decode:w};var m=p;const b=[{name:"base58",charset:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"},{name:"base64",charset:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"},{name:"base64url",charset:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"}];function v(t){for(const e of b)if(e.name===t)return e.charset;throw TypeError("Charset does not exist: "+t)}var x={encode:function(t,e,n=!1){const r=v(e),i=r.length,o=[];let s,a,c,f="",u=0;for(s=0;s<t.length;s++)for(u=0,a=t[s],f+=a>0||(f.length^s)>0?"":"1";u in o||a>0;)c=o[u],c=c>0?256*c+a:a,a=c/i|0,o[u]=c%i,u++;for(;u-- >0;)f+=r[o[u]];return n&&f.length%4>0?f+"=".repeat(4-f.length%4):f},decode:function(t,e){const n=v(e),r=n.length,i=[],o=[];t=t.replace("=","");let s,a,c,f=0;for(s=0;s<t.length;s++){if(f=0,a=n.indexOf(t[s]),a<0)throw new Error(`Character range out of bounds: ${a}`);for(s=a>0||(o.length^s)>0?s:o.push(0);f in i||a>0;)c=i[f],c=c>0?c*r+a:a,a=c>>8,i[f]=c%256,f++}for(;f-- >0;)o.push(i[f]);return Uint8Array.from(o)}};class E extends Uint8Array{constructor(t,e){if(void 0!==e){const n=new Uint8Array(e).fill(0);n.set(new Uint8Array(t)),t=n.buffer}return super(t),this}toArr(){return Array.from(this)}toStr(){return S(this)}toNum(){return function(t){let e,n=0;for(e=t.length-1;e>=0;e--)n=256*n+t[e];return Number(n)}(this)}toBig(){return function(t){let e,n=0n;for(e=t.length-1;e>=0;e--)n=256n*n+BigInt(t[e]);return BigInt(n)}(this)}toHex(){return function(t){const e=[];let n;for(n=0;n<t.length;n++)e.push(t[n].toString(16).padStart(2,"0"));return e.join("")}(this)}toJson(){return JSON.parse(S(this))}toBytes(){return new Uint8Array(this)}toBech32(t,e){return m.encode(this,t,e)}toBase58(){return x.encode(this,"base58")}toBase64(t){return x.encode(this,"base64",t)}toB64url(){return x.encode(this,"base64url")}prepend(t){return E.of(...t,...this)}append(t){return E.of(...this,...t)}slice(t,e){const n=new Uint8Array(this.buffer).slice(t,e);return new E(n.buffer)}write(t,e){this.set(t,e)}varint(t){return E.of(...this,...E.varint(t))}static from(t){return new E(Uint8Array.from(t).buffer)}static of(...t){return new E(Uint8Array.of(...t).buffer)}static join(t){let e,n=0;const r=t.reduce(((t,e)=>t+e.length),0),i=new Uint8Array(r);for(const r of t)for(e=0;e<r.length;n++,e++)i[n]=r[e];return new E(i,r)}static varint(t){if(t<253)return E.num(t,1);if(t<65536)return E.of(253,...E.num(t,2));if(t<4294967296)return E.of(254,...E.num(t,4));if(t<0x10000000000000000)return E.of(255,...E.num(t,8));throw new Error(`Value is too large: ${t}`)}}function A(t){return(new TextEncoder).encode(t).buffer}function S(t){return(new TextDecoder).decode(t)}E.str=(t,e)=>new E(A(t),e),E.hex=(t,e)=>new E(function(t){const e=[];let n,r=0;if(t.length%2>0)throw new Error(`Invalid hex string length: ${t.length}`);for(n=0;n<t.length;n+=2)e[r]=parseInt(t.slice(n,n+2),16),r+=1;return Uint8Array.from(e).buffer}(t),e),E.num=(t,e)=>new E(function(t){const e=[];for(;t>0;){const n=255&t;e.push(n),t=(t-n)/256}return Uint8Array.from(e).buffer}(t),e),E.big=(t,e)=>new E(function(t){const e=[];for(;t>0n;){const n=0xffn&t;e.push(Number(n)),t=(t-n)/256n}return Uint8Array.from(e).buffer}(t),e),E.buff=(t,e)=>new E(t,e),E.json=t=>new E(A(JSON.stringify(t))),E.bech32=(t,e)=>new E(m.decode(t,e)),E.base58=t=>new E(x.decode(t,"base58")),E.base64=t=>new E(x.decode(t,"base64")),E.b64url=t=>new E(x.decode(t,"base64url"));const B={null:t=>null===t,undefined:t=>void 0===t,hex:t=>function(t){switch(!0){case"string"!=typeof t:case/[^0-9a-fA-F]/.test(t):case t.length%2!=0:return!1;default:return!0}}(t),string:t=>"string"==typeof t,infinity:t=>t===1/0,bigint:t=>"bigint"==typeof t,number:t=>"number"==typeof t,class:t=>"object"==typeof t?.prototype&&t.toString().startsWith("class"),function:t=>"function"==typeof t,uint8:t=>t instanceof Uint8Array,uint16:t=>t instanceof Uint16Array,uint32:t=>t instanceof Uint32Array,buffer:t=>t instanceof ArrayBuffer,array:t=>Array.isArray(t),object:t=>"object"==typeof t};var U={of:t=>{for(const[e,n]of Object.entries(B))if(!0===n(t))return e;return"unknown"},array:{isString:t=>t.every((t=>B.string(t))),isNumber:t=>t.every((t=>B.number(t))),isBigint:t=>t.every((t=>B.bigint(t)))},is:B};
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */const I=BigInt(0),R=BigInt(1),_=BigInt(2),k=BigInt(3),P=BigInt(8),T=Object.freeze({a:I,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:R,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")});function H(t){const{a:e,b:n}=T,r=tt(t*t),i=tt(r*t);return tt(i+e*t+n)}const C=T.a===I;class N extends Error{constructor(t){super(t)}}class z{constructor(t,e,n){this.x=t,this.y=e,this.z=n}static fromAffine(t){if(!(t instanceof $))throw new TypeError("JacobianPoint#fromAffine: expected Point");return new z(t.x,t.y,R)}static toAffineBatch(t){const e=function(t,e=T.P){const n=new Array(t.length),r=nt(t.reduce(((t,r,i)=>r===I?t:(n[i]=t,tt(t*r,e))),R),e);return t.reduceRight(((t,r,i)=>r===I?t:(n[i]=tt(t*n[i],e),tt(t*r,e))),r),n}(t.map((t=>t.z)));return t.map(((t,n)=>t.toAffine(e[n])))}static normalizeZ(t){return z.toAffineBatch(t).map(z.fromAffine)}equals(t){if(!(t instanceof z))throw new TypeError("JacobianPoint expected");const{x:e,y:n,z:r}=this,{x:i,y:o,z:s}=t,a=tt(r*r),c=tt(s*s),f=tt(e*c),u=tt(i*a),h=tt(tt(n*s)*c),l=tt(tt(o*r)*a);return f===u&&h===l}negate(){return new z(this.x,tt(-this.y),this.z)}double(){const{x:t,y:e,z:n}=this,r=tt(t*t),i=tt(e*e),o=tt(i*i),s=t+i,a=tt(_*(tt(s*s)-r-o)),c=tt(k*r),f=tt(c*c),u=tt(f-_*a),h=tt(c*(a-u)-P*o),l=tt(_*e*n);return new z(u,h,l)}add(t){if(!(t instanceof z))throw new TypeError("JacobianPoint expected");const{x:e,y:n,z:r}=this,{x:i,y:o,z:s}=t;if(i===I||o===I)return this;if(e===I||n===I)return t;const a=tt(r*r),c=tt(s*s),f=tt(e*c),u=tt(i*a),h=tt(tt(n*s)*c),l=tt(tt(o*r)*a),d=tt(u-f),y=tt(l-h);if(d===I)return y===I?this.double():z.ZERO;const g=tt(d*d),w=tt(d*g),p=tt(f*g),m=tt(y*y-w-_*p),b=tt(y*(p-m)-h*w),v=tt(r*s*d);return new z(m,b,v)}subtract(t){return this.add(t.negate())}multiplyUnsafe(t){const e=z.ZERO;if("bigint"==typeof t&&t===I)return e;let n=Q(t);if(n===R)return this;if(!C){let t=e,r=this;for(;n>I;)n&R&&(t=t.add(r)),r=r.double(),n>>=R;return t}let{k1neg:r,k1:i,k2neg:o,k2:s}=ot(n),a=e,c=e,f=this;for(;i>I||s>I;)i&R&&(a=a.add(f)),s&R&&(c=c.add(f)),f=f.double(),i>>=R,s>>=R;return r&&(a=a.negate()),o&&(c=c.negate()),c=new z(tt(c.x*T.beta),c.y,c.z),a.add(c)}precomputeWindow(t){const e=C?128/t+1:256/t+1,n=[];let r=this,i=r;for(let o=0;o<e;o++){i=r,n.push(i);for(let e=1;e<2**(t-1);e++)i=i.add(r),n.push(i);r=i.double()}return n}wNAF(t,e){!e&&this.equals(z.BASE)&&(e=$.BASE);const n=e&&e._WINDOW_SIZE||1;if(256%n)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let r=e&&O.get(e);r||(r=this.precomputeWindow(n),e&&1!==n&&(r=z.normalizeZ(r),O.set(e,r)));let i=z.ZERO,o=z.ZERO;const s=1+(C?128/n:256/n),a=2**(n-1),c=BigInt(2**n-1),f=2**n,u=BigInt(n);for(let e=0;e<s;e++){const n=e*a;let s=Number(t&c);if(t>>=u,s>a&&(s-=f,t+=R),0===s){let t=r[n];e%2&&(t=t.negate()),o=o.add(t)}else{let t=r[n+Math.abs(s)-1];s<0&&(t=t.negate()),i=i.add(t)}}return{p:i,f:o}}multiply(t,e){let n,r,i=Q(t);if(C){const{k1neg:t,k1:o,k2neg:s,k2:a}=ot(i);let{p:c,f:f}=this.wNAF(o,e),{p:u,f:h}=this.wNAF(a,e);t&&(c=c.negate()),s&&(u=u.negate()),u=new z(tt(u.x*T.beta),u.y,u.z),n=c.add(u),r=f.add(h)}else{const{p:t,f:o}=this.wNAF(i,e);n=t,r=o}return z.normalizeZ([n,r])[0]}toAffine(t=nt(this.z)){const{x:e,y:n,z:r}=this,i=t,o=tt(i*i),s=tt(o*i),a=tt(e*o),c=tt(n*s);if(tt(r*i)!==R)throw new Error("invZ was invalid");return new $(a,c)}}z.BASE=new z(T.Gx,T.Gy,R),z.ZERO=new z(I,R,I);const O=new WeakMap;let $=class{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,O.delete(this)}hasEvenY(){return this.y%_===I}static fromCompressedHex(t){const e=32===t.length,n=G(e?t:t.subarray(1));if(!ht(n))throw new Error("Point is not on curve");let r=function(t){const{P:e}=T,n=BigInt(6),r=BigInt(11),i=BigInt(22),o=BigInt(23),s=BigInt(44),a=BigInt(88),c=t*t*t%e,f=c*c*t%e,u=et(f,k)*f%e,h=et(u,k)*f%e,l=et(h,_)*c%e,d=et(l,r)*l%e,y=et(d,i)*d%e,g=et(y,s)*y%e,w=et(g,a)*g%e,p=et(w,s)*y%e,m=et(p,k)*f%e,b=et(m,o)*d%e,v=et(b,n)*c%e;return et(v,_)}(H(n));const i=(r&R)===R;if(e)i&&(r=tt(-r));else{1==(1&t[0])!==i&&(r=tt(-r))}const o=new $(n,r);return o.assertValidity(),o}static fromUncompressedHex(t){const e=G(t.subarray(1,33)),n=G(t.subarray(33,65)),r=new $(e,n);return r.assertValidity(),r}static fromHex(t){const e=M(t),n=e.length,r=e[0];if(32===n||33===n&&(2===r||3===r))return this.fromCompressedHex(e);if(65===n&&4===r)return this.fromUncompressedHex(e);throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${n}`)}static fromPrivateKey(t){return $.BASE.multiply(dt(t))}static fromSignature(t,e,n){const r=st(t=M(t)),{r:i,s:o}=gt(e);if(0!==n&&1!==n)throw new Error("Cannot recover signature: invalid recovery bit");const s=1&n?"03":"02",a=$.fromHex(s+Z(i)),{n:c}=T,f=nt(i,c),u=tt(-r*f,c),h=tt(o*f,c),l=$.BASE.multiplyAndAddUnsafe(a,u,h);if(!l)throw new Error("Cannot recover signature: point at infinify");return l.assertValidity(),l}toRawBytes(t=!1){return Y(this.toHex(t))}toHex(t=!1){const e=Z(this.x);if(t){return`${this.hasEvenY()?"02":"03"}${e}`}return`04${e}${Z(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const t="Point is not on elliptic curve",{x:e,y:n}=this;if(!ht(e)||!ht(n))throw new Error(t);const r=tt(n*n);if(tt(r-H(e))!==I)throw new Error(t)}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new $(this.x,tt(-this.y))}double(){return z.fromAffine(this).double().toAffine()}add(t){return z.fromAffine(this).add(z.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return z.fromAffine(this).multiply(t,this).toAffine()}multiplyAndAddUnsafe(t,e,n){const r=z.fromAffine(this),i=e===I||e===R||this!==$.BASE?r.multiplyUnsafe(e):r.multiply(e),o=z.fromAffine(t).multiplyUnsafe(n),s=i.add(o);return s.equals(z.ZERO)?void 0:s.toAffine()}};function q(t){return Number.parseInt(t[0],16)>=8?"00"+t:t}function j(t){if(t.length<2||2!==t[0])throw new Error(`Invalid signature integer tag: ${X(t)}`);const e=t[1],n=t.subarray(2,e+2);if(!e||n.length!==e)throw new Error("Invalid signature integer: wrong length");if(0===n[0]&&n[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:G(n),left:t.subarray(e+2)}}$.BASE=new $(T.Gx,T.Gy),$.ZERO=new $(I,I);class D{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromCompact(t){const e=t instanceof Uint8Array,n="Signature.fromCompact";if("string"!=typeof t&&!e)throw new TypeError(`${n}: Expected string or Uint8Array`);const r=e?X(t):t;if(128!==r.length)throw new Error(`${n}: Expected 64-byte hex`);return new D(J(r.slice(0,64)),J(r.slice(64,128)))}static fromDER(t){const e=t instanceof Uint8Array;if("string"!=typeof t&&!e)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r:n,s:r}=function(t){if(t.length<2||48!=t[0])throw new Error(`Invalid signature tag: ${X(t)}`);if(t[1]!==t.length-2)throw new Error("Invalid signature: incorrect length");const{data:e,left:n}=j(t.subarray(2)),{data:r,left:i}=j(n);if(i.length)throw new Error(`Invalid signature: left bytes after parsing: ${X(i)}`);return{r:e,s:r}}(e?t:Y(t));return new D(n,r)}static fromHex(t){return this.fromDER(t)}assertValidity(){const{r:t,s:e}=this;if(!ut(t))throw new Error("Invalid Signature: r must be 0 < r < n");if(!ut(e))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const t=T.n>>R;return this.s>t}normalizeS(){return this.hasHighS()?new D(this.r,T.n-this.s):this}toDERRawBytes(t=!1){return Y(this.toDERHex(t))}toDERHex(t=!1){const e=q(L(this.s));if(t)return e;const n=q(L(this.r)),r=L(n.length/2),i=L(e.length/2);return`30${L(n.length/2+e.length/2+4)}02${r}${n}02${i}${e}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return Y(this.toCompactHex())}toCompactHex(){return Z(this.r)+Z(this.s)}}function V(...t){if(!t.every((t=>t instanceof Uint8Array)))throw new Error("Uint8Array list expected");if(1===t.length)return t[0];const e=t.reduce(((t,e)=>t+e.length),0),n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const i=t[e];n.set(i,r),r+=i.length}return n}const K=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function X(t){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");let e="";for(let n=0;n<t.length;n++)e+=K[t[n]];return e}const W=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function Z(t){if("bigint"!=typeof t)throw new Error("Expected bigint");if(!(I<=t&&t<W))throw new Error("Expected number < 2^256");return t.toString(16).padStart(64,"0")}function F(t){const e=Y(Z(t));if(32!==e.length)throw new Error("Error: expected 32 bytes");return e}function L(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function J(t){if("string"!=typeof t)throw new TypeError("hexToNumber: expected string, got "+typeof t);return BigInt(`0x${t}`)}function Y(t){if("string"!=typeof t)throw new TypeError("hexToBytes: expected string, got "+typeof t);if(t.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+t.length);const e=new Uint8Array(t.length/2);for(let n=0;n<e.length;n++){const r=2*n,i=t.slice(r,r+2),o=Number.parseInt(i,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");e[n]=o}return e}function G(t){return J(X(t))}function M(t){return t instanceof Uint8Array?Uint8Array.from(t):Y(t)}function Q(t){if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)return BigInt(t);if("bigint"==typeof t&&ut(t))return t;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function tt(t,e=T.P){const n=t%e;return n>=I?n:e+n}function et(t,e){const{P:n}=T;let r=t;for(;e-- >I;)r*=r,r%=n;return r}function nt(t,e=T.P){if(t===I||e<=I)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=tt(t,e),r=e,i=I,o=R;for(;n!==I;){const t=r%n,e=i-o*(r/n);r=n,n=t,i=o,o=e}if(r!==R)throw new Error("invert: does not exist");return tt(i,e)}const rt=(t,e)=>(t+e/_)/e,it={a1:BigInt("0x3086d221a7d46bcde86c90e49284eb15"),b1:-R*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),a2:BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),b2:BigInt("0x3086d221a7d46bcde86c90e49284eb15"),POW_2_128:BigInt("0x100000000000000000000000000000000")};function ot(t){const{n:e}=T,{a1:n,b1:r,a2:i,b2:o,POW_2_128:s}=it,a=rt(o*t,e),c=rt(-r*t,e);let f=tt(t-a*n-c*i,e),u=tt(-a*r-c*o,e);const h=f>s,l=u>s;if(h&&(f=e-f),l&&(u=e-u),f>s||u>s)throw new Error("splitScalarEndo: Endomorphism failed, k="+t);return{k1neg:h,k1:f,k2neg:l,k2:u}}function st(t){const{n:e}=T,n=8*t.length-256;let r=G(t);return n>0&&(r>>=BigInt(n)),r>=e&&(r-=e),r}let at,ct;class ft{constructor(){this.v=new Uint8Array(32).fill(1),this.k=new Uint8Array(32).fill(0),this.counter=0}hmac(...t){return Ct.hmacSha256(this.k,...t)}hmacSync(...t){return ct(this.k,...t)}checkSync(){if("function"!=typeof ct)throw new N("hmacSha256Sync needs to be set")}incr(){if(this.counter>=1e3)throw new Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(t=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),t),this.v=await this.hmac(this.v),0!==t.length&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),t),this.v=await this.hmac(this.v))}reseedSync(t=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),t),this.v=this.hmacSync(this.v),0!==t.length&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),t),this.v=this.hmacSync(this.v))}async generate(){return this.incr(),this.v=await this.hmac(this.v),this.v}generateSync(){return this.checkSync(),this.incr(),this.v=this.hmacSync(this.v),this.v}}function ut(t){return I<t&&t<T.n}function ht(t){return I<t&&t<T.P}function lt(t,e,n){const r=G(t);if(!ut(r))return;const{n:i}=T,o=$.BASE.multiply(r),s=tt(o.x,i);if(s===I)return;const a=tt(nt(r,i)*tt(e+n*s,i),i);if(a===I)return;const c=new D(s,a);return{sig:c,recovery:(o.x===c.r?0:2)|Number(o.y&R)}}function dt(t){let e;if("bigint"==typeof t)e=t;else if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)e=BigInt(t);else if("string"==typeof t){if(64!==t.length)throw new Error("Expected 32 bytes of private key");e=J(t)}else{if(!(t instanceof Uint8Array))throw new TypeError("Expected valid private key");if(32!==t.length)throw new Error("Expected 32 bytes of private key");e=G(t)}if(!ut(e))throw new Error("Expected private key: 0 < key < n");return e}function yt(t){return t instanceof $?(t.assertValidity(),t):$.fromHex(t)}function gt(t){if(t instanceof D)return t.assertValidity(),t;try{return D.fromDER(t)}catch(e){return D.fromCompact(t)}}function wt(t){const e=t instanceof Uint8Array,n="string"==typeof t,r=(e||n)&&t.length;return e?33===r||65===r:n?66===r||130===r:t instanceof $}function pt(t){return G(t.length>32?t.slice(0,32):t)}function mt(t){const e=pt(t),n=tt(e,T.n);return bt(n<I?e:n)}function bt(t){return F(t)}function vt(t,e,n){if(null==t)throw new Error(`sign: expected valid message hash, not "${t}"`);const r=M(t),i=dt(e),o=[bt(i),mt(r)];if(null!=n){!0===n&&(n=Ct.randomBytes(32));const t=M(n);if(32!==t.length)throw new Error("sign: Expected 32 bytes of extra data");o.push(t)}return{seed:V(...o),m:pt(r),d:i}}function xt(t,e){let{sig:n,recovery:r}=t;const{canonical:i,der:o,recovered:s}=Object.assign({canonical:!0,der:!0},e);i&&n.hasHighS()&&(n=n.normalizeS(),r^=1);const a=o?n.toDERRawBytes():n.toCompactRawBytes();return s?[a,r]:a}const Et={strict:!0};function At(t){return tt(G(t),T.n)}class St{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromHex(t){const e=M(t);if(64!==e.length)throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${e.length}`);const n=G(e.subarray(0,32)),r=G(e.subarray(32,64));return new St(n,r)}assertValidity(){const{r:t,s:e}=this;if(!ht(t)||!ut(e))throw new Error("Invalid signature")}toHex(){return Z(this.r)+Z(this.s)}toRawBytes(){return Y(this.toHex())}}class Bt{constructor(t,e,n=Ct.randomBytes()){if(null==t)throw new TypeError(`sign: Expected valid message, not "${t}"`);this.m=M(t);const{x:r,scalar:i}=this.getScalar(dt(e));if(this.px=r,this.d=i,this.rand=M(n),32!==this.rand.length)throw new TypeError("sign: Expected 32 bytes of aux randomness")}getScalar(t){const e=$.fromPrivateKey(t),n=e.hasEvenY()?t:T.n-t;return{point:e,scalar:n,x:e.toRawX()}}initNonce(t,e){return F(t^G(e))}finalizeNonce(t){const e=tt(G(t),T.n);if(e===I)throw new Error("sign: Creation of signature failed. k is zero");const{point:n,x:r,scalar:i}=this.getScalar(e);return{R:n,rx:r,k:i}}finalizeSig(t,e,n,r){return new St(t.x,tt(e+n*r,T.n)).toRawBytes()}error(){throw new Error("sign: Invalid signature produced")}async calc(){const{m:t,d:e,px:n,rand:r}=this,i=Ct.taggedHash,o=this.initNonce(e,await i(Tt.aux,r)),{R:s,rx:a,k:c}=this.finalizeNonce(await i(Tt.nonce,o,n,t)),f=At(await i(Tt.challenge,a,n,t)),u=this.finalizeSig(s,c,f,e);return await Rt(u,t,n)||this.error(),u}calcSync(){const{m:t,d:e,px:n,rand:r}=this,i=Ct.taggedHashSync,o=this.initNonce(e,i(Tt.aux,r)),{R:s,rx:a,k:c}=this.finalizeNonce(i(Tt.nonce,o,n,t)),f=At(i(Tt.challenge,a,n,t)),u=this.finalizeSig(s,c,f,e);return _t(u,t,n)||this.error(),u}}function Ut(t,e,n){const r=t instanceof St,i=r?t:St.fromHex(t);return r&&i.assertValidity(),{...i,m:M(e),P:yt(n)}}function It(t,e,n,r){const i=$.BASE.multiplyAndAddUnsafe(e,dt(n),tt(-r,T.n));return!(!i||!i.hasEvenY()||i.x!==t)}async function Rt(t,e,n){try{const{r:r,s:i,m:o,P:s}=Ut(t,e,n),a=At(await Ct.taggedHash(Tt.challenge,F(r),s.toRawX(),o));return It(r,s,i,a)}catch(t){return!1}}function _t(t,e,n){try{const{r:r,s:i,m:o,P:s}=Ut(t,e,n),a=At(Ct.taggedHashSync(Tt.challenge,F(r),s.toRawX(),o));return It(r,s,i,a)}catch(t){if(t instanceof N)throw t;return!1}}const kt={Signature:St,getPublicKey:function(t){return $.fromPrivateKey(t).toRawX()},sign:async function(t,e,n){return new Bt(t,e,n).calc()},verify:Rt,signSync:function(t,e,n){return new Bt(t,e,n).calcSync()},verifySync:_t};$.BASE._setWindowSize(8);const Pt={node:o,web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},Tt={challenge:"BIP0340/challenge",aux:"BIP0340/aux",nonce:"BIP0340/nonce"},Ht={},Ct={bytesToHex:X,hexToBytes:Y,concatBytes:V,mod:tt,invert:nt,isValidPrivateKey(t){try{return dt(t),!0}catch(t){return!1}},_bigintTo32Bytes:F,_normalizePrivateKey:dt,hashToPrivateKey:t=>{if((t=M(t)).length<40||t.length>1024)throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");return F(tt(G(t),T.n-R)+R)},randomBytes:(t=32)=>{if(Pt.web)return Pt.web.getRandomValues(new Uint8Array(t));if(Pt.node){const{randomBytes:e}=Pt.node;return Uint8Array.from(e(t))}throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>Ct.hashToPrivateKey(Ct.randomBytes(40)),sha256:async(...t)=>{if(Pt.web){const e=await Pt.web.subtle.digest("SHA-256",V(...t));return new Uint8Array(e)}if(Pt.node){const{createHash:e}=Pt.node,n=e("sha256");return t.forEach((t=>n.update(t))),Uint8Array.from(n.digest())}throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(t,...e)=>{if(Pt.web){const n=await Pt.web.subtle.importKey("raw",t,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),r=V(...e),i=await Pt.web.subtle.sign("HMAC",n,r);return new Uint8Array(i)}if(Pt.node){const{createHmac:n}=Pt.node,r=n("sha256",t);return e.forEach((t=>r.update(t))),Uint8Array.from(r.digest())}throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(t,...e)=>{let n=Ht[t];if(void 0===n){const e=await Ct.sha256(Uint8Array.from(t,(t=>t.charCodeAt(0))));n=V(e,e),Ht[t]=n}return Ct.sha256(n,...e)},taggedHashSync:(t,...e)=>{if("function"!=typeof at)throw new N("sha256Sync is undefined, you need to set it");let n=Ht[t];if(void 0===n){const e=at(Uint8Array.from(t,(t=>t.charCodeAt(0))));n=V(e,e),Ht[t]=n}return at(n,...e)},precompute(t=8,e=$.BASE){const n=e===$.BASE?e:new $(e.x,e.y);return n._setWindowSize(t),n.multiply(k),n}};Object.defineProperties(Ct,{sha256Sync:{configurable:!1,get:()=>at,set(t){at||(at=t)}},hmacSha256Sync:{configurable:!1,get:()=>ct,set(t){ct||(ct=t)}}});var Nt=Object.freeze({__proto__:null,CURVE:T,Point:$,Signature:D,getPublicKey:function(t,e=!1){return $.fromPrivateKey(t).toRawBytes(e)},recoverPublicKey:function(t,e,n,r=!1){return $.fromSignature(t,e,n).toRawBytes(r)},getSharedSecret:function(t,e,n=!1){if(wt(t))throw new TypeError("getSharedSecret: first arg must be private key");if(!wt(e))throw new TypeError("getSharedSecret: second arg must be public key");const r=yt(e);return r.assertValidity(),r.multiply(dt(t)).toRawBytes(n)},sign:async function(t,e,n={}){const{seed:r,m:i,d:o}=vt(t,e,n.extraEntropy);let s;const a=new ft;for(await a.reseed(r);!(s=lt(await a.generate(),i,o));)await a.reseed();return xt(s,n)},signSync:function(t,e,n={}){const{seed:r,m:i,d:o}=vt(t,e,n.extraEntropy);let s;const a=new ft;for(a.reseedSync(r);!(s=lt(a.generateSync(),i,o));)a.reseedSync();return xt(s,n)},verify:function(t,e,n,r=Et){let i;try{i=gt(t),e=M(e)}catch(t){return!1}const{r:o,s:s}=i;if(r.strict&&i.hasHighS())return!1;const a=st(e);let c;try{c=yt(n)}catch(t){return!1}const{n:f}=T,u=nt(s,f),h=tt(a*u,f),l=tt(o*u,f),d=$.BASE.multiplyAndAddUnsafe(c,h,l);return!!d&&tt(d.x,f)===o},schnorr:kt,utils:Ct});let zt=class extends Uint8Array{constructor(t){super(t="bigint"==typeof t?E.big(t).reverse():t)}static mod(t,e=zt.N){return new zt(Ct.mod(t,e))}get num(){const t=new Uint8Array(this).reverse();return E.buff(t).toBig()}get point(){return Ot.fromScalar(this.num)}gt(t){return new zt(t).num>this.num}lt(t){return new zt(t).num<this.num}eq(t){return new zt(t).num===this.num}ne(t){return new zt(t).num!==this.num}add(t){const e=new zt(t);return zt.mod(this.num+e.num)}sub(t){const e=new zt(t);return zt.mod(this.num-e.num)}mul(t){const e=new zt(t);return zt.mod(this.num*e.num)}pow(t,e=zt.N-1n){const n=new zt(t),r=zt.mod(n.num,e);return zt.mod(this.num**r.num)}div(t){const e=new zt(t),n=this.pow(e.num,zt.N-2n);return zt.mod(this.num*n.num)}};zt.N=T.n,zt.isField=t=>t instanceof zt;class Ot{constructor(t,e){this.__p=new $(t,e),this.__x=this.__p.x,this.__y=this.__p.y}static fromScalar(t){const e=t instanceof Uint8Array?E.buff(t.reverse()).toBig():"number"==typeof t?BigInt(t):t,n=$.BASE.multiply(e);return new Ot(n.x,n.y)}static from(t){return new Ot(t.x,t.y)}get p(){return this.__p}get rawX(){const t=this.__p.hasEvenY()?2:3,e=E.big(this.__x);return Uint8Array.of(t,...e.reverse())}get rawXR(){const t=this.__p.hasEvenY()?2:3,e=E.big(this.__x);return Uint8Array.of(t,...e)}get rawY(){return E.big(this.__y).reverse()}get x(){return this.__x}get y(){return this.__y}eq(t){return t instanceof Ot?this.p.equals(new $(t.x,t.y)):t instanceof Uint8Array?this.x.toString()===t.toString():t===this.x}add(t){return t instanceof Ot?Ot.from(this.p.add(t.p)):Ot.from(this.p.add(Ot.fromScalar(t).p))}sub(t){return t instanceof Ot?Ot.from(this.p.subtract(t.p)):Ot.from(this.p.subtract(Ot.fromScalar(t).p))}mul(t){return t instanceof Ot?Ot.from(this.p.multiply(t.x)):Ot.from(this.p.multiply(Ot.fromScalar(t).x))}}var $t=Object.freeze({__proto__:null,Field:zt,Point:Ot,Noble:Nt});const qt=new TextEncoder,{Field:jt}=$t,Dt=E.hex("3ddd5602285899a946114506157c7997e5444528f3003f6134712147db19b678"),Vt=new jt(BigInt("0x3ddd5602285899a946114506157c7997e5444528f3003f6134712147db19b678")),Kt=new jt(Dt),Xt=Kt.point,Wt=i.pointFromScalar(Dt,!0);if(null===Wt)throw TypeError("Encountered null value!");const Zt=E.buff(qt.encode("test"),32),Ft=i.sign(Zt,Kt),Lt=i.sign(Zt,Dt),Jt=E.num(10,32),Yt=Kt.add(Jt),Gt=i.privateAdd(Dt,Jt),Mt=Xt.add(Jt),Qt=i.pointAddScalar(Wt,Jt.reverse(),!0),te=i.pointAddScalar(Xt.rawX,Jt,!0);if(null===Gt||null===Qt||null===te)throw TypeError("Encountered null value!");const ee=i.sign(Zt,Yt),ne=i.sign(Zt,Gt);const re=/[\p{Lu}]/u,ie=/[\p{Ll}]/u,oe=/^[\p{Lu}](?![\p{Lu}])/gu,se=/([\p{Alpha}\p{N}_]|$)/u,ae=/[_.\- ]+/,ce=new RegExp("^"+ae.source),fe=new RegExp(ae.source+se.source,"gu"),ue=new RegExp("\\d+"+se.source,"gu");function he(t,e){if("string"!=typeof t&&!Array.isArray(t))throw new TypeError("Expected the input to be `string | string[]`");if(e={pascalCase:!1,preserveConsecutiveUppercase:!1,...e},0===(t=Array.isArray(t)?t.map((t=>t.trim())).filter((t=>t.length)).join("-"):t.trim()).length)return"";const n=!1===e.locale?t=>t.toLowerCase():t=>t.toLocaleLowerCase(e.locale),r=!1===e.locale?t=>t.toUpperCase():t=>t.toLocaleUpperCase(e.locale);if(1===t.length)return ae.test(t)?"":e.pascalCase?r(t):n(t);return t!==n(t)&&(t=((t,e,n)=>{let r=!1,i=!1,o=!1;for(let s=0;s<t.length;s++){const a=t[s];r&&re.test(a)?(t=t.slice(0,s)+"-"+t.slice(s),r=!1,o=i,i=!0,s++):i&&o&&ie.test(a)?(t=t.slice(0,s-1)+"-"+t.slice(s-1),o=i,i=!1,r=!0):(r=e(a)===a&&n(a)!==a,o=i,i=n(a)===a&&e(a)!==a)}return t})(t,n,r)),t=t.replace(ce,""),t=e.preserveConsecutiveUppercase?((t,e)=>(oe.lastIndex=0,t.replace(oe,(t=>e(t)))))(t,n):n(t),e.pascalCase&&(t=r(t.charAt(0))+t.slice(1)),((t,e)=>(fe.lastIndex=0,ue.lastIndex=0,t.replace(fe,((t,n)=>e(n))).replace(ue,(t=>e(t)))))(t,r)}var le="@cmdcode/crypto-utils";const de="../src/index.js";let ye;async function ge(t){ye=t;const e=he(String("/"+le).split("/").at(-1)),n=await async function(t){if("undefined"!=typeof window)return window[t];const e=process?.argv&&process.argv.length>2?process.argv.slice(2,3):de;if(String(e).includes("main"))throw new Error("Unable to run tests on a commonJs module!");return console.log(`Testing package: ${e}`),import("../"+e).then((t=>t.default?t.default:t))}(e);we(n)}async function we(t,e=[]){for(const[n,r]of Object.entries(t))if(U.is.class(r)){const t=[...e,n];pe(r,t),we(r,t),console.log("Registering tests for class:",n)}else if(U.is.function(r))me(n,r,e);else if(U.is.object(r)){we(r,[...e,n])}}async function pe(t,e){const n=[...e,"new"];for(const e of Object.getOwnPropertyNames(t.prototype))me(e,t,n)}async function me(t,e,n){const r=`./src/${n.join("/").toLowerCase()}/${t}.test.js`;import(r).then((t=>{for(const n of Object.keys(t))ye.test(r.split("/").at(-1),(r=>{console.log(`Running ${n} tests:\n`),t[n](r,e)}))})).catch((t=>{t.message.includes("Cannot find module")||console.log(`Failed to import test for: ${r}\n${t}`)}))}t("Crypto-Utils Test Suite",(async t=>{t.test("ECC Tests",(t=>{"undefined"==typeof window&&function(t){t.plan(15),t.equal(Vt.num,Kt.num,"should be equal as bigints"),t.deepEqual(Vt,Kt,"should be equal uints"),t.deepEqual(new Uint8Array(Kt),new Uint8Array(Dt),"should be equal seed values"),t.deepEqual(Xt.rawX,Wt,"should be equal points"),t.equal(i.verify(Zt,Wt,Ft),!0,"sig1A and K2 should be valid"),t.equal(i.verify(Zt,Xt.rawX,Lt),!0,"sig1B and K1 should be valid"),t.deepEqual(new Uint8Array(Yt),new Uint8Array(Gt),"our tweaked scalar should match ecc scalar"),t.deepEqual(Mt.rawX,Qt,"our tweaked point should match ecc point"),t.deepEqual(Qt,te,"ecc points should match when tweaking point or scalar"),t.equal(i.verify(Zt,Mt.rawX,ee),!0,"T1 should verify signature 2A"),t.equal(i.verify(Zt,Qt,ee),!0,"T2 should verify signature 2A"),t.equal(i.verify(Zt,te,ee),!0,"T3 should verify signature 2A"),t.equal(i.verify(Zt,Mt.rawX,ne),!0,"T1 should verify signature 2B"),t.equal(i.verify(Zt,Qt,ne),!0,"T2 should verify signature 2B"),t.equal(i.verify(Zt,te,ne),!0,"T3 should verify signature 2B")}(t)})),t.test("API Crawler Tests",(async t=>{await ge(t)}))}))}(tape,ecc,crypto);
