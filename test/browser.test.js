!function(t,e,n){"use strict";function r(t){var e=Object.create(null);return t&&Object.keys(t).forEach((function(n){if("default"!==n){var r=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(e,n,r.get?r:{enumerable:!0,get:function(){return t[n]}})}})),e.default=t,Object.freeze(e)}var i=r(e),o=r(n);
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const s=BigInt(0),a=BigInt(1),c=BigInt(2),u=BigInt(3),f=BigInt(8),l=Object.freeze({a:s,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:a,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")});function h(t){const{a:e,b:n}=l,r=R(t*t),i=R(r*t);return R(i+e*t+n)}const y=l.a===s;class d extends Error{constructor(t){super(t)}}class w{constructor(t,e,n){this.x=t,this.y=e,this.z=n}static fromAffine(t){if(!(t instanceof p))throw new TypeError("JacobianPoint#fromAffine: expected Point");return new w(t.x,t.y,a)}static toAffineBatch(t){const e=function(t,e=l.P){const n=new Array(t.length),r=_(t.reduce(((t,r,i)=>r===s?t:(n[i]=t,R(t*r,e))),a),e);return t.reduceRight(((t,r,i)=>r===s?t:(n[i]=R(t*n[i],e),R(t*r,e))),r),n}(t.map((t=>t.z)));return t.map(((t,n)=>t.toAffine(e[n])))}static normalizeZ(t){return w.toAffineBatch(t).map(w.fromAffine)}equals(t){if(!(t instanceof w))throw new TypeError("JacobianPoint expected");const{x:e,y:n,z:r}=this,{x:i,y:o,z:s}=t,a=R(r*r),c=R(s*s),u=R(e*c),f=R(i*a),l=R(R(n*s)*c),h=R(R(o*r)*a);return u===f&&l===h}negate(){return new w(this.x,R(-this.y),this.z)}double(){const{x:t,y:e,z:n}=this,r=R(t*t),i=R(e*e),o=R(i*i),s=t+i,a=R(c*(R(s*s)-r-o)),l=R(u*r),h=R(l*l),y=R(h-c*a),d=R(l*(a-y)-f*o),g=R(c*e*n);return new w(y,d,g)}add(t){if(!(t instanceof w))throw new TypeError("JacobianPoint expected");const{x:e,y:n,z:r}=this,{x:i,y:o,z:a}=t;if(i===s||o===s)return this;if(e===s||n===s)return t;const u=R(r*r),f=R(a*a),l=R(e*f),h=R(i*u),y=R(R(n*a)*f),d=R(R(o*r)*u),g=R(h-l),p=R(d-y);if(g===s)return p===s?this.double():w.ZERO;const m=R(g*g),b=R(g*m),v=R(l*m),x=R(p*p-b-c*v),A=R(p*(v-x)-y*b),E=R(r*a*g);return new w(x,A,E)}subtract(t){return this.add(t.negate())}multiplyUnsafe(t){const e=w.ZERO;if("bigint"==typeof t&&t===s)return e;let n=H(t);if(n===a)return this;if(!y){let t=e,r=this;for(;n>s;)n&a&&(t=t.add(r)),r=r.double(),n>>=a;return t}let{k1neg:r,k1:i,k2neg:o,k2:c}=z(n),u=e,f=e,h=this;for(;i>s||c>s;)i&a&&(u=u.add(h)),c&a&&(f=f.add(h)),h=h.double(),i>>=a,c>>=a;return r&&(u=u.negate()),o&&(f=f.negate()),f=new w(R(f.x*l.beta),f.y,f.z),u.add(f)}precomputeWindow(t){const e=y?128/t+1:256/t+1,n=[];let r=this,i=r;for(let o=0;o<e;o++){i=r,n.push(i);for(let e=1;e<2**(t-1);e++)i=i.add(r),n.push(i);r=i.double()}return n}wNAF(t,e){!e&&this.equals(w.BASE)&&(e=p.BASE);const n=e&&e._WINDOW_SIZE||1;if(256%n)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let r=e&&g.get(e);r||(r=this.precomputeWindow(n),e&&1!==n&&(r=w.normalizeZ(r),g.set(e,r)));let i=w.ZERO,o=w.ZERO;const s=1+(y?128/n:256/n),c=2**(n-1),u=BigInt(2**n-1),f=2**n,l=BigInt(n);for(let e=0;e<s;e++){const n=e*c;let s=Number(t&u);if(t>>=l,s>c&&(s-=f,t+=a),0===s){let t=r[n];e%2&&(t=t.negate()),o=o.add(t)}else{let t=r[n+Math.abs(s)-1];s<0&&(t=t.negate()),i=i.add(t)}}return{p:i,f:o}}multiply(t,e){let n,r,i=H(t);if(y){const{k1neg:t,k1:o,k2neg:s,k2:a}=z(i);let{p:c,f:u}=this.wNAF(o,e),{p:f,f:h}=this.wNAF(a,e);t&&(c=c.negate()),s&&(f=f.negate()),f=new w(R(f.x*l.beta),f.y,f.z),n=c.add(f),r=u.add(h)}else{const{p:t,f:o}=this.wNAF(i,e);n=t,r=o}return w.normalizeZ([n,r])[0]}toAffine(t=_(this.z)){const{x:e,y:n,z:r}=this,i=t,o=R(i*i),s=R(o*i),c=R(e*o),u=R(n*s);if(R(r*i)!==a)throw new Error("invZ was invalid");return new p(c,u)}}w.BASE=new w(l.Gx,l.Gy,a),w.ZERO=new w(s,a,s);const g=new WeakMap;let p=class{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,g.delete(this)}hasEvenY(){return this.y%c===s}static fromCompressedHex(t){const e=32===t.length,n=C(e?t:t.subarray(1));if(!V(n))throw new Error("Point is not on curve");let r=function(t){const{P:e}=l,n=BigInt(6),r=BigInt(11),i=BigInt(22),o=BigInt(23),s=BigInt(44),a=BigInt(88),f=t*t*t%e,h=f*f*t%e,y=k(h,u)*h%e,d=k(y,u)*h%e,w=k(d,c)*f%e,g=k(w,r)*w%e,p=k(g,i)*g%e,m=k(p,s)*p%e,b=k(m,a)*m%e,v=k(b,s)*p%e,x=k(v,u)*h%e,A=k(x,o)*g%e,E=k(A,n)*f%e;return k(E,c)}(h(n));const i=(r&a)===a;if(e)i&&(r=R(-r));else{1==(1&t[0])!==i&&(r=R(-r))}const o=new p(n,r);return o.assertValidity(),o}static fromUncompressedHex(t){const e=C(t.subarray(1,33)),n=C(t.subarray(33,65)),r=new p(e,n);return r.assertValidity(),r}static fromHex(t){const e=T(t),n=e.length,r=e[0];if(32===n||33===n&&(2===r||3===r))return this.fromCompressedHex(e);if(65===n&&4===r)return this.fromUncompressedHex(e);throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${n}`)}static fromPrivateKey(t){return p.BASE.multiply(W(t))}static fromSignature(t,e,n){const r=O(t=T(t)),{r:i,s:o}=L(e);if(0!==n&&1!==n)throw new Error("Cannot recover signature: invalid recovery bit");const s=1&n?"03":"02",a=p.fromHex(s+F(i)),{n:c}=l,u=_(i,c),f=R(-r*u,c),h=R(o*u,c),y=p.BASE.multiplyAndAddUnsafe(a,f,h);if(!y)throw new Error("Cannot recover signature: point at infinify");return y.assertValidity(),y}toRawBytes(t=!1){return P(this.toHex(t))}toHex(t=!1){const e=F(this.x);if(t){return`${this.hasEvenY()?"02":"03"}${e}`}return`04${e}${F(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const t="Point is not on elliptic curve",{x:e,y:n}=this;if(!V(e)||!V(n))throw new Error(t);const r=R(n*n);if(R(r-h(e))!==s)throw new Error(t)}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new p(this.x,R(-this.y))}double(){return w.fromAffine(this).double().toAffine()}add(t){return w.fromAffine(this).add(w.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return w.fromAffine(this).multiply(t,this).toAffine()}multiplyAndAddUnsafe(t,e,n){const r=w.fromAffine(this),i=e===s||e===a||this!==p.BASE?r.multiplyUnsafe(e):r.multiply(e),o=w.fromAffine(t).multiplyUnsafe(n),c=i.add(o);return c.equals(w.ZERO)?void 0:c.toAffine()}};function m(t){return Number.parseInt(t[0],16)>=8?"00"+t:t}function b(t){if(t.length<2||2!==t[0])throw new Error(`Invalid signature integer tag: ${E(t)}`);const e=t[1],n=t.subarray(2,e+2);if(!e||n.length!==e)throw new Error("Invalid signature integer: wrong length");if(0===n[0]&&n[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:C(n),left:t.subarray(e+2)}}p.BASE=new p(l.Gx,l.Gy),p.ZERO=new p(s,s);class v{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromCompact(t){const e=t instanceof Uint8Array,n="Signature.fromCompact";if("string"!=typeof t&&!e)throw new TypeError(`${n}: Expected string or Uint8Array`);const r=e?E(t):t;if(128!==r.length)throw new Error(`${n}: Expected 64-byte hex`);return new v(I(r.slice(0,64)),I(r.slice(64,128)))}static fromDER(t){const e=t instanceof Uint8Array;if("string"!=typeof t&&!e)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r:n,s:r}=function(t){if(t.length<2||48!=t[0])throw new Error(`Invalid signature tag: ${E(t)}`);if(t[1]!==t.length-2)throw new Error("Invalid signature: incorrect length");const{data:e,left:n}=b(t.subarray(2)),{data:r,left:i}=b(n);if(i.length)throw new Error(`Invalid signature: left bytes after parsing: ${E(i)}`);return{r:e,s:r}}(e?t:P(t));return new v(n,r)}static fromHex(t){return this.fromDER(t)}assertValidity(){const{r:t,s:e}=this;if(!D(t))throw new Error("Invalid Signature: r must be 0 < r < n");if(!D(e))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const t=l.n>>a;return this.s>t}normalizeS(){return this.hasHighS()?new v(this.r,l.n-this.s):this}toDERRawBytes(t=!1){return P(this.toDERHex(t))}toDERHex(t=!1){const e=m(U(this.s));if(t)return e;const n=m(U(this.r)),r=U(n.length/2),i=U(e.length/2);return`30${U(n.length/2+e.length/2+4)}02${r}${n}02${i}${e}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return P(this.toCompactHex())}toCompactHex(){return F(this.r)+F(this.s)}}function x(...t){if(!t.every((t=>t instanceof Uint8Array)))throw new Error("Uint8Array list expected");if(1===t.length)return t[0];const e=t.reduce(((t,e)=>t+e.length),0),n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const i=t[e];n.set(i,r),r+=i.length}return n}const A=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function E(t){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");let e="";for(let n=0;n<t.length;n++)e+=A[t[n]];return e}const S=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function F(t){if("bigint"!=typeof t)throw new Error("Expected bigint");if(!(s<=t&&t<S))throw new Error("Expected number < 2^256");return t.toString(16).padStart(64,"0")}function B(t){const e=P(F(t));if(32!==e.length)throw new Error("Error: expected 32 bytes");return e}function U(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function I(t){if("string"!=typeof t)throw new TypeError("hexToNumber: expected string, got "+typeof t);return BigInt(`0x${t}`)}function P(t){if("string"!=typeof t)throw new TypeError("hexToBytes: expected string, got "+typeof t);if(t.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+t.length);const e=new Uint8Array(t.length/2);for(let n=0;n<e.length;n++){const r=2*n,i=t.slice(r,r+2),o=Number.parseInt(i,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");e[n]=o}return e}function C(t){return I(E(t))}function T(t){return t instanceof Uint8Array?Uint8Array.from(t):P(t)}function H(t){if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)return BigInt(t);if("bigint"==typeof t&&D(t))return t;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function R(t,e=l.P){const n=t%e;return n>=s?n:e+n}function k(t,e){const{P:n}=l;let r=t;for(;e-- >s;)r*=r,r%=n;return r}function _(t,e=l.P){if(t===s||e<=s)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=R(t,e),r=e,i=s,o=a;for(;n!==s;){const t=r%n,e=i-o*(r/n);r=n,n=t,i=o,o=e}if(r!==a)throw new Error("invert: does not exist");return R(i,e)}const q=(t,e)=>(t+e/c)/e,N={a1:BigInt("0x3086d221a7d46bcde86c90e49284eb15"),b1:-a*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),a2:BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),b2:BigInt("0x3086d221a7d46bcde86c90e49284eb15"),POW_2_128:BigInt("0x100000000000000000000000000000000")};function z(t){const{n:e}=l,{a1:n,b1:r,a2:i,b2:o,POW_2_128:s}=N,a=q(o*t,e),c=q(-r*t,e);let u=R(t-a*n-c*i,e),f=R(-a*r-c*o,e);const h=u>s,y=f>s;if(h&&(u=e-u),y&&(f=e-f),u>s||f>s)throw new Error("splitScalarEndo: Endomorphism failed, k="+t);return{k1neg:h,k1:u,k2neg:y,k2:f}}function O(t){const{n:e}=l,n=8*t.length-256;let r=C(t);return n>0&&(r>>=BigInt(n)),r>=e&&(r-=e),r}let $,K;class j{constructor(){this.v=new Uint8Array(32).fill(1),this.k=new Uint8Array(32).fill(0),this.counter=0}hmac(...t){return yt.hmacSha256(this.k,...t)}hmacSync(...t){return K(this.k,...t)}checkSync(){if("function"!=typeof K)throw new d("hmacSha256Sync needs to be set")}incr(){if(this.counter>=1e3)throw new Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(t=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),t),this.v=await this.hmac(this.v),0!==t.length&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),t),this.v=await this.hmac(this.v))}reseedSync(t=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),t),this.v=this.hmacSync(this.v),0!==t.length&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),t),this.v=this.hmacSync(this.v))}async generate(){return this.incr(),this.v=await this.hmac(this.v),this.v}generateSync(){return this.checkSync(),this.incr(),this.v=this.hmacSync(this.v),this.v}}function D(t){return s<t&&t<l.n}function V(t){return s<t&&t<l.P}function X(t,e,n){const r=C(t);if(!D(r))return;const{n:i}=l,o=p.BASE.multiply(r),c=R(o.x,i);if(c===s)return;const u=R(_(r,i)*R(e+n*c,i),i);if(u===s)return;const f=new v(c,u);return{sig:f,recovery:(o.x===f.r?0:2)|Number(o.y&a)}}function W(t){let e;if("bigint"==typeof t)e=t;else if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)e=BigInt(t);else if("string"==typeof t){if(64!==t.length)throw new Error("Expected 32 bytes of private key");e=I(t)}else{if(!(t instanceof Uint8Array))throw new TypeError("Expected valid private key");if(32!==t.length)throw new Error("Expected 32 bytes of private key");e=C(t)}if(!D(e))throw new Error("Expected private key: 0 < key < n");return e}function Z(t){return t instanceof p?(t.assertValidity(),t):p.fromHex(t)}function L(t){if(t instanceof v)return t.assertValidity(),t;try{return v.fromDER(t)}catch(e){return v.fromCompact(t)}}function J(t){const e=t instanceof Uint8Array,n="string"==typeof t,r=(e||n)&&t.length;return e?33===r||65===r:n?66===r||130===r:t instanceof p}function Y(t){return C(t.length>32?t.slice(0,32):t)}function G(t){const e=Y(t),n=R(e,l.n);return M(n<s?e:n)}function M(t){return B(t)}async function Q(t,e,n={}){const{seed:r,m:i,d:o}=function(t,e,n){if(null==t)throw new Error(`sign: expected valid message hash, not "${t}"`);const r=T(t),i=W(e),o=[M(i),G(r)];if(null!=n){!0===n&&(n=yt.randomBytes(32));const t=T(n);if(32!==t.length)throw new Error("sign: Expected 32 bytes of extra data");o.push(t)}return{seed:x(...o),m:Y(r),d:i}}(t,e,n.extraEntropy);let s;const a=new j;for(await a.reseed(r);!(s=X(await a.generate(),i,o));)await a.reseed();return function(t,e){let{sig:n,recovery:r}=t;const{canonical:i,der:o,recovered:s}=Object.assign({canonical:!0,der:!0},e);i&&n.hasHighS()&&(n=n.normalizeS(),r^=1);const a=o?n.toDERRawBytes():n.toCompactRawBytes();return s?[a,r]:a}(s,n)}const tt={strict:!0};function et(t,e,n,r=tt){let i;try{i=L(t),e=T(e)}catch(t){return!1}const{r:o,s:s}=i;if(r.strict&&i.hasHighS())return!1;const a=O(e);let c;try{c=Z(n)}catch(t){return!1}const{n:u}=l,f=_(s,u),h=R(a*f,u),y=R(o*f,u),d=p.BASE.multiplyAndAddUnsafe(c,h,y);if(!d)return!1;return R(d.x,u)===o}function nt(t){return R(C(t),l.n)}class rt{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromHex(t){const e=T(t);if(64!==e.length)throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${e.length}`);const n=C(e.subarray(0,32)),r=C(e.subarray(32,64));return new rt(n,r)}assertValidity(){const{r:t,s:e}=this;if(!V(t)||!D(e))throw new Error("Invalid signature")}toHex(){return F(this.r)+F(this.s)}toRawBytes(){return P(this.toHex())}}class it{constructor(t,e,n=yt.randomBytes()){if(null==t)throw new TypeError(`sign: Expected valid message, not "${t}"`);this.m=T(t);const{x:r,scalar:i}=this.getScalar(W(e));if(this.px=r,this.d=i,this.rand=T(n),32!==this.rand.length)throw new TypeError("sign: Expected 32 bytes of aux randomness")}getScalar(t){const e=p.fromPrivateKey(t),n=e.hasEvenY()?t:l.n-t;return{point:e,scalar:n,x:e.toRawX()}}initNonce(t,e){return B(t^C(e))}finalizeNonce(t){const e=R(C(t),l.n);if(e===s)throw new Error("sign: Creation of signature failed. k is zero");const{point:n,x:r,scalar:i}=this.getScalar(e);return{R:n,rx:r,k:i}}finalizeSig(t,e,n,r){return new rt(t.x,R(e+n*r,l.n)).toRawBytes()}error(){throw new Error("sign: Invalid signature produced")}async calc(){const{m:t,d:e,px:n,rand:r}=this,i=yt.taggedHash,o=this.initNonce(e,await i(lt.aux,r)),{R:s,rx:a,k:c}=this.finalizeNonce(await i(lt.nonce,o,n,t)),u=nt(await i(lt.challenge,a,n,t)),f=this.finalizeSig(s,c,u,e);return await at(f,t,n)||this.error(),f}calcSync(){const{m:t,d:e,px:n,rand:r}=this,i=yt.taggedHashSync,o=this.initNonce(e,i(lt.aux,r)),{R:s,rx:a,k:c}=this.finalizeNonce(i(lt.nonce,o,n,t)),u=nt(i(lt.challenge,a,n,t)),f=this.finalizeSig(s,c,u,e);return ct(f,t,n)||this.error(),f}}function ot(t,e,n){const r=t instanceof rt,i=r?t:rt.fromHex(t);return r&&i.assertValidity(),{...i,m:T(e),P:Z(n)}}function st(t,e,n,r){const i=p.BASE.multiplyAndAddUnsafe(e,W(n),R(-r,l.n));return!(!i||!i.hasEvenY()||i.x!==t)}async function at(t,e,n){try{const{r:r,s:i,m:o,P:s}=ot(t,e,n),a=nt(await yt.taggedHash(lt.challenge,B(r),s.toRawX(),o));return st(r,s,i,a)}catch(t){return!1}}function ct(t,e,n){try{const{r:r,s:i,m:o,P:s}=ot(t,e,n),a=nt(yt.taggedHashSync(lt.challenge,B(r),s.toRawX(),o));return st(r,s,i,a)}catch(t){if(t instanceof d)throw t;return!1}}const ut={Signature:rt,getPublicKey:function(t){return p.fromPrivateKey(t).toRawX()},sign:async function(t,e,n){return new it(t,e,n).calc()},verify:at,signSync:function(t,e,n){return new it(t,e,n).calcSync()},verifySync:ct};p.BASE._setWindowSize(8);const ft={node:i,web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},lt={challenge:"BIP0340/challenge",aux:"BIP0340/aux",nonce:"BIP0340/nonce"},ht={},yt={bytesToHex:E,hexToBytes:P,concatBytes:x,mod:R,invert:_,isValidPrivateKey(t){try{return W(t),!0}catch(t){return!1}},_bigintTo32Bytes:B,_normalizePrivateKey:W,hashToPrivateKey:t=>{if((t=T(t)).length<40||t.length>1024)throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");return B(R(C(t),l.n-a)+a)},randomBytes:(t=32)=>{if(ft.web)return ft.web.getRandomValues(new Uint8Array(t));if(ft.node){const{randomBytes:e}=ft.node;return Uint8Array.from(e(t))}throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>yt.hashToPrivateKey(yt.randomBytes(40)),sha256:async(...t)=>{if(ft.web){const e=await ft.web.subtle.digest("SHA-256",x(...t));return new Uint8Array(e)}if(ft.node){const{createHash:e}=ft.node,n=e("sha256");return t.forEach((t=>n.update(t))),Uint8Array.from(n.digest())}throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(t,...e)=>{if(ft.web){const n=await ft.web.subtle.importKey("raw",t,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),r=x(...e),i=await ft.web.subtle.sign("HMAC",n,r);return new Uint8Array(i)}if(ft.node){const{createHmac:n}=ft.node,r=n("sha256",t);return e.forEach((t=>r.update(t))),Uint8Array.from(r.digest())}throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(t,...e)=>{let n=ht[t];if(void 0===n){const e=await yt.sha256(Uint8Array.from(t,(t=>t.charCodeAt(0))));n=x(e,e),ht[t]=n}return yt.sha256(n,...e)},taggedHashSync:(t,...e)=>{if("function"!=typeof $)throw new d("sha256Sync is undefined, you need to set it");let n=ht[t];if(void 0===n){const e=$(Uint8Array.from(t,(t=>t.charCodeAt(0))));n=x(e,e),ht[t]=n}return $(n,...e)},precompute(t=8,e=p.BASE){const n=e===p.BASE?e:new p(e.x,e.y);return n._setWindowSize(t),n.multiply(u),n}};Object.defineProperties(yt,{sha256Sync:{configurable:!1,get:()=>$,set(t){$||($=t)}},hmacSha256Sync:{configurable:!1,get:()=>K,set(t){K||(K=t)}}});const dt="qpzry9x8gf2tvdw0s3jn54khce6mua7l",wt=[996825010,642813549,513874426,1027748829,705979059],gt="bech32",pt="bech32m";function mt(t){switch(t){case gt:return 1;case pt:return 734539939;default:throw new Error(`Unrecognized encoding: ${t}`)}}function bt(t){let e=1;for(let n=0;n<t.length;++n){const r=e>>25;e=(33554431&e)<<5^t[n];for(let t=0;t<5;++t)(r>>t&1)>0&&(e^=wt[t])}return e}function vt(t){const e=[];let n;for(n=0;n<t.length;++n)e.push(t.charCodeAt(n)>>5);for(e.push(0),n=0;n<t.length;++n)e.push(31&t.charCodeAt(n));return e}function xt(t,e,n,r=!0){const i=[];let o=0,s=0;const a=(1<<n)-1,c=(1<<e+n-1)-1;for(const r of t){if(r<0||r>>e>0)return[];for(o=(o<<e|r)&c,s+=e;s>=n;)s-=n,i.push(o>>s&a)}if(r)s>0&&i.push(o<<n-s&a);else if(s>=e||(o<<n-s&a)>0)return[];return i}function At(t,e,n){const r=e.concat(function(t,e,n){const r=bt(vt(t).concat(e).concat([0,0,0,0,0,0]))^mt(n),i=[];for(let t=0;t<6;++t)i.push(r>>5*(5-t)&31);return i}(t,e,n));let i=t+"1";for(let t=0;t<r.length;++t)i+=dt.charAt(r[t]);return i}function Et(t,e){const n=e>0?"bech32m":"bech32";if(!function(t){let e,n,r=!1,i=!1;for(e=0;e<t.length;++e){if(n=t.charCodeAt(e),n<33||n>126)return!1;n>=97&&n<=122&&(r=!0),n>=65&&n<=90&&(i=!0)}return!(r&&i)}(t))return{hrp:null,data:[255]};if(!function(t){const e=t.lastIndexOf("1");return!(e<1||e+7>t.length||t.length>90)}(t=t.toLowerCase()))return{hrp:null,data:[255]};const r=[],i=t.lastIndexOf("1"),o=t.substring(0,i);for(let e=i+1;e<t.length;++e){const n=dt.indexOf(t.charAt(e));if(-1===n)return{hrp:null,data:[255]};r.push(n)}return function(t,e,n){return bt(vt(t).concat(e))===mt(n)}(o,r,n)?{hrp:o,data:r.slice(0,r.length-6)}:{hrp:null,data:[255]}}function St(t,e=0){const n=t.split("1",1)[0],{hrp:r,data:i}=Et(t,e),o=xt(i.slice(1),5,8,!1),s=o.length;switch(!0){case n!==r:throw new Error("Returned hrp string is invalid.");case null===o||s<2||s>40:throw new Error("Decoded string is invalid or out of spec.");case i[0]>16:throw new Error("Returned version bit is out of range.");case 0===i[0]&&20!==s&&32!==s:throw new Error("Decoded string does not match version 0 spec.");case 0===i[0]&&0!==e:case 0!==i[0]&&1!==e:throw new Error("Decoded version bit does not match.");default:return Uint8Array.from(o)}}const Ft={encode:function(t,e="bch",n=0){const r=At(e,[n,...xt([...t],8,5)],n>0?"bech32m":"bech32");return St(r,n),r},decode:St};var Bt=Ft;const Ut=[{name:"base58",charset:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"},{name:"base64",charset:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"},{name:"base64url",charset:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"}];function It(t){for(const e of Ut)if(e.name===t)return e.charset;throw TypeError("Charset does not exist: "+t)}var Pt={encode:function(t,e,n=!1){const r=It(e),i=r.length,o=[];let s,a,c,u="",f=0;for(s=0;s<t.length;s++)for(f=0,a=t[s],u+=a>0||(u.length^s)>0?"":"1";f in o||a>0;)c=o[f],c=c>0?256*c+a:a,a=c/i|0,o[f]=c%i,f++;for(;f-- >0;)u+=r[o[f]];return n&&u.length%4>0?u+"=".repeat(4-u.length%4):u},decode:function(t,e){const n=It(e),r=n.length,i=[],o=[];t=t.replace("=","");let s,a,c,u=0;for(s=0;s<t.length;s++){if(u=0,a=n.indexOf(t[s]),a<0)throw new Error(`Character range out of bounds: ${a}`);for(s=a>0||(o.length^s)>0?s:o.push(0);u in i||a>0;)c=i[u],c=c>0?c*r+a:a,a=c>>8,i[u]=c%256,u++}for(;u-- >0;)o.push(i[u]);return Uint8Array.from(o)}};class Ct extends Uint8Array{constructor(t,e=null,n="be"){if(null!==e){const n=new Uint8Array(e).fill(0);n.set(new Uint8Array(t)),t=n.buffer}return super(t="le"===n?new Uint8Array(t).reverse():t),this}toNum(t="le"){return Rt("le"===t?this.reverse():this)}toBig(t="le"){return kt("le"===t?this.reverse():this)}toArr(){return Array.from(this)}toStr(){return Ht(this)}toHex(){return function(t){const e=[];let n;for(n=0;n<t.length;n++)e.push(t[n].toString(16).padStart(2,"0"));return e.join("")}(this)}toJson(){return JSON.parse(Ht(this))}toBytes(){return new Uint8Array(this)}toBech32(t,e){return Bt.encode(this,t,e)}toBase58(){return Pt.encode(this,"base58")}toBase64(t){return Pt.encode(this,"base64",t)}toB64url(){return Pt.encode(this,"base64url")}prepend(t){return Ct.of(...t,...this)}append(t){return Ct.of(...this,...t)}slice(t,e){return new Ct(new Uint8Array(this).slice(t,e))}reverse(){return new Ct(new Uint8Array(this).reverse())}write(t,e){this.set(t,e)}addVarint(t=this.length){return Ct.of(...Ct.getVarint(t),...this)}static from(t){return new Ct(Uint8Array.from(t))}static of(...t){return new Ct(Uint8Array.of(...t))}static join(t){let e,n=0;const r=t.reduce(((t,e)=>t+e.length),0),i=new Uint8Array(r);for(const r of t)for(e=0;e<r.length;n++,e++)i[n]=r[e];return new Ct(i,r)}static getVarint(t){if(t<253)return Ct.num(t,1);if(t<65536)return Ct.of(253,...Ct.num(t,2));if(t<4294967296)return Ct.of(254,...Ct.num(t,4));if(t<0x10000000000000000)return Ct.of(255,...Ct.num(t,8));throw new Error(`Value is too large: ${t}`)}}function Tt(t){return(new TextEncoder).encode(t).buffer}function Ht(t){return(new TextDecoder).decode(t)}function Rt(t){let e,n=0;for(e=t.length-1;e>=0;e--)n=256*n+t[e];return Number(n)}function kt(t){let e,n=0n;for(e=t.length-1;e>=0;e--)n=256n*n+BigInt(t[e]);return BigInt(n)}Ct.num=(t,e,n="le")=>new Ct(function(t){const e=[];for(;t>0;){const n=255&t;e.push(n),t=(t-n)/256}return Uint8Array.from(e)}(t),e,n),Ct.big=(t,e,n="le")=>new Ct(function(t){const e=[];for(;t>0n;){const n=0xffn&t;e.push(Number(n)),t=(t-n)/256n}return Uint8Array.from(e)}(t),e,n),Ct.buff=(t,e)=>new Ct(t,e),Ct.str=(t,e)=>new Ct(Tt(t),e),Ct.hex=(t,e)=>new Ct(function(t){const e=[];let n,r=0;if(t.length%2>0)throw new Error(`Invalid hex string length: ${t.length}`);for(n=0;n<t.length;n+=2)e[r]=parseInt(t.slice(n,n+2),16),r+=1;return Uint8Array.from(e).buffer}(t),e),Ct.json=t=>new Ct(Tt(JSON.stringify(t))),Ct.bech32=(t,e)=>new Ct(Bt.decode(t,e)),Ct.base58=t=>new Ct(Pt.decode(t,"base58")),Ct.base64=t=>new Ct(Pt.decode(t,"base64")),Ct.b64url=t=>new Ct(Pt.decode(t,"base64url"));const _t={null:t=>null===t,undefined:t=>void 0===t,hex:t=>function(t){switch(!0){case"string"!=typeof t:case/[^0-9a-fA-F]/.test(t):case t.length%2!=0:return!1;default:return!0}}(t),string:t=>"string"==typeof t,infinity:t=>t===1/0,bigint:t=>"bigint"==typeof t,number:t=>"number"==typeof t,class:t=>"object"==typeof t?.prototype&&t.toString().startsWith("class"),function:t=>"function"==typeof t,uint8:t=>t instanceof Uint8Array,uint16:t=>t instanceof Uint16Array,uint32:t=>t instanceof Uint32Array,buffer:t=>t instanceof ArrayBuffer,array:t=>Array.isArray(t),object:t=>"object"==typeof t};var qt={of:t=>{for(const[e,n]of Object.entries(_t))if(!0===n(t))return e;return"unknown"},array:{isString:t=>t.every((t=>_t.string(t))),isNumber:t=>t.every((t=>_t.number(t))),isBigint:t=>t.every((t=>_t.bigint(t)))},is:_t};function Nt(t=32){return e.webcrypto.getRandomValues(new Uint8Array(t))}function zt(t){return"string"==typeof t?Ct.hex(t).toBytes():t}function Ot(t){return"string"==typeof t?Ct.str(t).toBytes():t}let $t=class extends Uint8Array{constructor(t){t=t instanceof Uint8Array?Ct.from(t).toBig():"number"==typeof t?BigInt(t):t,super(t=Ct.big($t.mod(t)))}static mod(t,e=$t.N){return yt.mod(t,e)}static fromPrivate(t){if(t<=0)throw new TypeError("Number cannot be negative.");if(t>=$t.N)throw new TypeError("Number cannot be greater than N: 2**256 - 2**32 - 977");return new $t(t)}get num(){const t=new Uint8Array(this);return Ct.buff(t).toBig()}get point(){return Kt.fromScalar(this.num)}gt(t){return new $t(t).num>this.num}lt(t){return new $t(t).num<this.num}eq(t){return new $t(t).num===this.num}ne(t){return new $t(t).num!==this.num}add(t){const e=new $t(t);return new $t(this.num+e.num)}sub(t){const e=new $t(t);return new $t(this.num-e.num)}mul(t){const e=new $t(t);return new $t(this.num*e.num)}pow(t,e=$t.N-1n){const n=new $t(t),r=$t.mod(n.num,e);return new $t(this.num**r)}div(t){const e=new $t(t),n=this.pow(e.num,$t.N-2n);return new $t(this.num*n.num)}};$t.N=l.n,$t.isField=t=>t instanceof $t;let Kt=class{constructor(t,e){this.__p=new p(t,e),this.__x=this.__p.x,this.__y=this.__p.y}static fromScalar(t){const e=t instanceof Uint8Array?Ct.from(t).toBig():"number"==typeof t?BigInt(t):t,n=yt.mod(e,Kt.N),r=p.BASE.multiply(n);return new Kt(r.x,r.y)}static fromX(t){const e=Ct.buff(t).toHex();return Kt.from(p.fromHex(e))}static from(t){return new Kt(t.x,t.y)}get p(){return this.__p}get rawX(){const t=this.__p.hasEvenY()?2:3,e=Ct.big(this.__x);return Uint8Array.of(t,...e)}get rawXR(){const t=this.__p.hasEvenY()?2:3,e=Ct.big(this.__x);return Uint8Array.of(t,...e)}get rawY(){return Ct.big(this.__y)}get x(){return this.__x}get y(){return this.__y}eq(t){return t instanceof Kt?this.p.equals(new p(t.x,t.y)):t instanceof Uint8Array?this.x.toString()===t.toString():"number"==typeof t?BigInt(t)===this.x:t===this.x}add(t){return t instanceof Kt?Kt.from(this.p.add(t.p)):Kt.from(this.p.add(Kt.fromScalar(t).p))}sub(t){return t instanceof Kt?Kt.from(this.p.subtract(t.p)):Kt.from(this.p.subtract(Kt.fromScalar(t).p))}mul(t){if(t instanceof Uint8Array){const e=Ct.from(t).toBig();return Kt.from(this.p.multiply(e))}return t instanceof Kt?Kt.from(this.p.multiply(t.x)):Kt.from(this.p.multiply(t))}};Kt.N=l.n;class jt{constructor(t){this._secret="string"==typeof t?Ct.hex(t).toBytes():t}get field(){return new $t(this._secret)}get point(){return this.field.point}get privateKey(){return new Uint8Array(this.field)}get privateHex(){return new Ct(this.field).toHex()}get publicKey(){return new Uint8Array(this.point.rawX)}get publicHex(){return new Ct(this.publicKey).toHex()}}var Dt=Object.freeze({__proto__:null,Field:$t,Point:Kt,KeyPair:jt});async function Vt(t){return e.webcrypto.subtle.importKey("raw",t,{name:"AES-CBC"},!0,["encrypt","decrypt"])}async function Xt(t,n){return t instanceof CryptoKey&&(t=await async function(t){return e.webcrypto.subtle.exportKey("raw",t).then((t=>new Uint8Array(t)))}(t)),function(t,e,n=!1){if(J(t))throw new TypeError("getSharedSecret: first arg must be private key");if(!J(e))throw new TypeError("getSharedSecret: second arg must be public key");const r=Z(e);return r.assertValidity(),r.multiply(W(t)).toRawBytes(n)}(t,n,!0)}async function Wt(t,e){return Vt((await Xt(t,e)).slice(1,33))}class Zt{constructor(t){this.secret=t instanceof Uint8Array?Vt(t):t}static async encrypt(t,n,r){const i=r??e.webcrypto.getRandomValues(new Uint8Array(16));return e.webcrypto.subtle.encrypt({name:"AES-CBC",iv:i},t,n).then((t=>Uint8Array.of(...i,...new Uint8Array(t))))}static async decrypt(t,n){return e.webcrypto.subtle.decrypt({name:"AES-CBC",iv:n.slice(0,16)},t,n.slice(16)).then((t=>new Uint8Array(t)))}async encrypt(t,e){const n=await this.secret;return Zt.encrypt(n,t,e)}async decrypt(t){const e=await this.secret;return Zt.decrypt(e,t)}async encryptShared(t,e,n){const r=await this.secret,i=zt(t),o=await Wt(r,i);return Zt.encrypt(o,e,n)}async decryptShared(t,e){const n=await this.secret,r=zt(t),i=await Wt(n,r);return Zt.decrypt(i,e)}}async function Lt(t){t.test("Test encryption/decryption of Cipher suite.",(async t=>{const e=Nt(32),n=Nt(32),{publicKey:r}=new jt(Nt(32)),i=Zt.from(e),o=await i.encrypt(n),s=await i.decrypt(o),a=await i.encryptShared(r,n),c=await i.decryptShared(r,a);t.plan(2),t.deepEqual(n,s,"Decrypted data should equal test data."),t.deepEqual(n,c,"Decrypted data should equal test data.")}))}Zt.from=t=>new Zt(zt(t));class Jt extends jt{constructor(t,e){super(t),this.type=e??"schnorr"}static from(t,e){return new Jt(zt(t),e)}async sign(t){const e=Ot(t);return"schnorr"===this.type?ut.sign(e,this.privateKey):Q(e,this.privateKey)}async verify(t,e){const n=Ot(t),r=zt(e);return"schnorr"===this.type?ut.verify(r,n,Yt(this.publicKey)):et(r,n,this.publicKey)}static async verify(t,e,n,r){r=void 0!==r?r:"schnorr";const i=Ot(t),o=zt(e),s=zt(n);return"schnorr"===r?ut.verify(s,i,Yt(o)):et(s,i,o)}}function Yt(t){return 33===t.length?t.slice(1):t}async function Gt(t){return async function(t,n="SHA-256",r=1){let i,o=t.buffer;for(i=0;i<r;i++)o=await e.webcrypto.subtle.digest(n,o);return new Uint8Array(o)}(t,"SHA-256")}const Mt=Nt(32),Qt=Nt(32);async function te(t){t.test("Test signing/validation of Noble library.",(async t=>{const e=yt.isValidPrivateKey(Mt),n=ut.getPublicKey(Mt),r=function(t,e=!1){return p.fromPrivateKey(t).toRawBytes(e)}(Mt,!0),i=await ut.sign(Qt,Mt),o=await Q(Qt,Mt),s=await ut.verify(i,Qt,n),a=et(o,Qt,r);t.plan(3),t.equal(e,!0,"Private key should be valid."),t.equal(s,!0,"Schnorr signature should be valid."),t.equal(a,!0,"ECDSA signature should be valid.")}))}const ee=Nt(32),ne=Nt(32);const re=new TextEncoder,{Field:ie}=Dt,oe=Ct.hex("80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF");o.pointFromScalar(oe),p.BASE.multiply(BigInt("0x80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF"));const se=ie.fromPrivate(oe),ae=se.point,ce=o.pointFromScalar(oe,!0);if(null===ce)throw TypeError("Encountered null value!");const ue=Ct.buff(re.encode("test"),32),fe=o.sign(ue,se),le=o.sign(ue,oe),he=Ct.num(150,32),ye=se.add(he),de=o.privateAdd(oe,he),we=ae.add(he),ge=o.pointAddScalar(ce,he,!0),pe=o.pointAddScalar(ae.rawX,he,!0);if(null===de||null===ge||null===pe)throw TypeError("Encountered null value!");const me=o.sign(ue,ye),be=o.sign(ue,de);const{Field:ve,Point:xe}=Dt,Ae=new TextEncoder;const{Field:Ee,Point:Se}=Dt,Fe=new TextEncoder;const Be=/[\p{Lu}]/u,Ue=/[\p{Ll}]/u,Ie=/^[\p{Lu}](?![\p{Lu}])/gu,Pe=/([\p{Alpha}\p{N}_]|$)/u,Ce=/[_.\- ]+/,Te=new RegExp("^"+Ce.source),He=new RegExp(Ce.source+Pe.source,"gu"),Re=new RegExp("\\d+"+Pe.source,"gu");function ke(t,e){if("string"!=typeof t&&!Array.isArray(t))throw new TypeError("Expected the input to be `string | string[]`");if(e={pascalCase:!1,preserveConsecutiveUppercase:!1,...e},0===(t=Array.isArray(t)?t.map((t=>t.trim())).filter((t=>t.length)).join("-"):t.trim()).length)return"";const n=!1===e.locale?t=>t.toLowerCase():t=>t.toLocaleLowerCase(e.locale),r=!1===e.locale?t=>t.toUpperCase():t=>t.toLocaleUpperCase(e.locale);if(1===t.length)return Ce.test(t)?"":e.pascalCase?r(t):n(t);return t!==n(t)&&(t=((t,e,n)=>{let r=!1,i=!1,o=!1;for(let s=0;s<t.length;s++){const a=t[s];r&&Be.test(a)?(t=t.slice(0,s)+"-"+t.slice(s),r=!1,o=i,i=!0,s++):i&&o&&Ue.test(a)?(t=t.slice(0,s-1)+"-"+t.slice(s-1),o=i,i=!1,r=!0):(r=e(a)===a&&n(a)!==a,o=i,i=n(a)===a&&e(a)!==a)}return t})(t,n,r)),t=t.replace(Te,""),t=e.preserveConsecutiveUppercase?((t,e)=>(Ie.lastIndex=0,t.replace(Ie,(t=>e(t)))))(t,n):n(t),e.pascalCase&&(t=r(t.charAt(0))+t.slice(1)),((t,e)=>(He.lastIndex=0,Re.lastIndex=0,t.replace(He,((t,n)=>e(n))).replace(Re,(t=>e(t)))))(t,r)}var _e="@cmdcode/crypto-utils";const qe="../src/index.js";let Ne;async function ze(t){Ne=t;const e=ke(String("/"+_e).split("/").at(-1)),n=await async function(t){if("undefined"!=typeof window)return window[t];const e=process?.argv&&process.argv.length>2?process.argv.slice(2,3):qe;if(String(e).includes("main"))throw new Error("Unable to run tests on a commonJs module!");return console.log(`Testing package: ${e}`),import("../"+e).then((t=>t.default?t.default:t))}(e);Oe(n)}async function Oe(t,e=[]){for(const[n,r]of Object.entries(t))if(qt.is.class(r)){const t=[...e,n];$e(r,t),Oe(r,t),console.log("Registering tests for class:",n)}else if(qt.is.function(r))Ke(n,r,e);else if(qt.is.object(r)){Oe(r,[...e,n])}}async function $e(t,e){const n=[...e,"new"];for(const e of Object.getOwnPropertyNames(t.prototype))Ke(e,t,n)}async function Ke(t,e,n){const r=`./src/${n.join("/").toLowerCase()}/${t}.test.js`;import(r).then((t=>{for(const n of Object.keys(t))Ne.test(r.split("/").at(-1),(r=>{console.log(`Running ${n} tests:\n`),t[n](r,e)}))})).catch((t=>{t.message.includes("Cannot find module")||console.log(`Failed to import test for: ${r}\n${t}`)}))}const{Field:je,Point:De}=Dt;t("Crypto-Utils Test Suite",(async t=>{t.test("Cipher Tests",(t=>{Lt(t)})),t.test("Signer Tests",(t=>{te(t),async function(t){t.test("Test signing/validation of Signer suite.",(async t=>{const e=Jt.from(ee),n=Jt.from(ee,"ecdsa"),r=e.publicKey,i=n.publicKey,o=await e.sign(ne),s=await n.sign(ne),a=await e.verify(ne,o),c=await n.verify(ne,s),u=await Jt.verify(ne,r,o),f=await Jt.verify(ne,i,s,"ecdsa");t.plan(4),t.equal(a,!0,"Schnorr signature A should be valid."),t.equal(c,!0,"ECDSA signature B should be valid."),t.equal(u,!0,"Schnorr signature C should be valid."),t.equal(f,!0,"ECDSA signature D should be valid.")}))}(t)})),t.test("ECC Tests",(t=>{!function(t){t.test("Testing ECC Primitives",(t=>{t.plan(13),t.deepEqual(new Uint8Array(se),new Uint8Array(oe),"should be equal seed values"),t.deepEqual(ae.rawX,ce,"should be equal points"),t.equal(o.verify(ue,ce,fe),!0,"sig1A and K2 should be valid"),t.equal(o.verify(ue,ae.rawX,le),!0,"sig1B and K1 should be valid"),t.deepEqual(new Uint8Array(ye),new Uint8Array(de),"our tweaked scalar should match ecc scalar"),t.deepEqual(we.rawX,ge,"our tweaked point should match ecc point"),t.deepEqual(ge,pe,"ecc points should match when tweaking point or scalar"),t.equal(o.verify(ue,we.rawX,me),!0,"T1 should verify signature 2A"),t.equal(o.verify(ue,ge,me),!0,"T2 should verify signature 2A"),t.equal(o.verify(ue,pe,me),!0,"T3 should verify signature 2A"),t.equal(o.verify(ue,we.rawX,be),!0,"T1 should verify signature 2B"),t.equal(o.verify(ue,ge,be),!0,"T2 should verify signature 2B"),t.equal(o.verify(ue,pe,be),!0,"T3 should verify signature 2B")}))}(t),function(t){t.test("Testing ECC Schnorr Signatures",(async t=>{const e=Nt(32),n=e.reverse(),r=new Uint8Array(32);r.set(Ae.encode("test message"));const i=ve.fromPrivate(e),o=xe.from(i.point),s=ve.fromPrivate(n),a=xe.from(s.point),c=await Gt(Uint8Array.of(...r,...a.rawX)),u=s.sub(i.mul(c)).point.x,f=a.sub(o.mul(c)).x;t.plan(1),t.equal(u,f,"signature derivations should be equal.")}))}(t),async function(t){t.test("Testing ECC Discrete Log Signatures",(async t=>{const e=new Uint8Array(32),n=new Uint8Array(32);e.set(Fe.encode("cloudy day")),n.set(Fe.encode("bitcoin transaction"));const r=Ee.fromPrivate(Nt(32)),i=Se.from(r.point),o=Ee.fromPrivate(Nt(32)),s=Se.from(o.point),a=Ee.fromPrivate(Nt(32)),c=Se.from(a.point),u=await Gt(Uint8Array.of(...e,...s.rawX)),f=await Gt(Uint8Array.of(...n,...c.rawX)),l=s.sub(i.mul(u)),h=o.sub(r.mul(u)),y=a.sub(h.mul(f)),d=c.sub(l.mul(f));t.plan(2),t.equal(h.point.x,l.x,"signature proofs should be equal."),t.equal(y.point.x,d.x,"dlc proofs should be equal.")}))}(t),function(t){t.test("Testing Shared Secret Derivation",(async t=>{const e=je.fromPrivate(Nt(32)),n=De.from(e.point),r=je.fromPrivate(Nt(32)),i=De.from(r.point).mul(e.num).x,o=n.mul(r.num).x;t.plan(1),t.equal(i,o,"shared secrets should be equal.")}))}(t)})),t.test("API Crawler Tests",(async t=>{await ze(t)}))}))}(tape,crypto,ecc);
