!function(t,e,n){"use strict";function r(t){var e=Object.create(null);return t&&Object.keys(t).forEach((function(n){if("default"!==n){var r=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(e,n,r.get?r:{enumerable:!0,get:function(){return t[n]}})}})),e.default=t,Object.freeze(e)}var i=r(e),o=r(n);const s="qpzry9x8gf2tvdw0s3jn54khce6mua7l",a=[996825010,642813549,513874426,1027748829,705979059],c="bech32",f="bech32m";function u(t){switch(t){case c:return 1;case f:return 734539939;default:throw new Error(`Unrecognized encoding: ${t}`)}}function h(t){let e=1;for(let n=0;n<t.length;++n){const r=e>>25;e=(33554431&e)<<5^t[n];for(let t=0;t<5;++t)(r>>t&1)>0&&(e^=a[t])}return e}function l(t){const e=[];let n;for(n=0;n<t.length;++n)e.push(t.charCodeAt(n)>>5);for(e.push(0),n=0;n<t.length;++n)e.push(31&t.charCodeAt(n));return e}function d(t,e,n,r=!0){const i=[];let o=0,s=0;const a=(1<<n)-1,c=(1<<e+n-1)-1;for(const r of t){if(r<0||r>>e>0)return[];for(o=(o<<e|r)&c,s+=e;s>=n;)s-=n,i.push(o>>s&a)}if(r)s>0&&i.push(o<<n-s&a);else if(s>=e||(o<<n-s&a)>0)return[];return i}function y(t,e,n){const r=e.concat(function(t,e,n){const r=h(l(t).concat(e).concat([0,0,0,0,0,0]))^u(n),i=[];for(let t=0;t<6;++t)i.push(r>>5*(5-t)&31);return i}(t,e,n));let i=t+"1";for(let t=0;t<r.length;++t)i+=s.charAt(r[t]);return i}function g(t,e){const n=e>0?"bech32m":"bech32";if(!function(t){let e,n,r=!1,i=!1;for(e=0;e<t.length;++e){if(n=t.charCodeAt(e),n<33||n>126)return!1;n>=97&&n<=122&&(r=!0),n>=65&&n<=90&&(i=!0)}return!(r&&i)}(t))return{hrp:null,data:[255]};if(!function(t){const e=t.lastIndexOf("1");return!(e<1||e+7>t.length||t.length>90)}(t=t.toLowerCase()))return{hrp:null,data:[255]};const r=[],i=t.lastIndexOf("1"),o=t.substring(0,i);for(let e=i+1;e<t.length;++e){const n=s.indexOf(t.charAt(e));if(-1===n)return{hrp:null,data:[255]};r.push(n)}return function(t,e,n){return h(l(t).concat(e))===u(n)}(o,r,n)?{hrp:o,data:r.slice(0,r.length-6)}:{hrp:null,data:[255]}}function w(t,e=0){const n=t.split("1",1)[0],{hrp:r,data:i}=g(t,e),o=d(i.slice(1),5,8,!1),s=o.length;switch(!0){case n!==r:throw new Error("Returned hrp string is invalid.");case null===o||s<2||s>40:throw new Error("Decoded string is invalid or out of spec.");case i[0]>16:throw new Error("Returned version bit is out of range.");case 0===i[0]&&20!==s&&32!==s:throw new Error("Decoded string does not match version 0 spec.");case 0===i[0]&&0!==e:case 0!==i[0]&&1!==e:throw new Error("Decoded version bit does not match.");default:return Uint8Array.from(o)}}const p={encode:function(t,e="bch",n=0){const r=y(e,[n,...d([...t],8,5)],n>0?"bech32m":"bech32");return w(r,n),r},decode:w};var m=p;const b=[{name:"base58",charset:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"},{name:"base64",charset:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"},{name:"base64url",charset:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"}];function x(t){for(const e of b)if(e.name===t)return e.charset;throw TypeError("Charset does not exist: "+t)}var v={encode:function(t,e,n=!1){const r=x(e),i=r.length,o=[];let s,a,c,f="",u=0;for(s=0;s<t.length;s++)for(u=0,a=t[s],f+=a>0||(f.length^s)>0?"":"1";u in o||a>0;)c=o[u],c=c>0?256*c+a:a,a=c/i|0,o[u]=c%i,u++;for(;u-- >0;)f+=r[o[u]];return n&&f.length%4>0?f+"=".repeat(4-f.length%4):f},decode:function(t,e){const n=x(e),r=n.length,i=[],o=[];t=t.replace("=","");let s,a,c,f=0;for(s=0;s<t.length;s++){if(f=0,a=n.indexOf(t[s]),a<0)throw new Error(`Character range out of bounds: ${a}`);for(s=a>0||(o.length^s)>0?s:o.push(0);f in i||a>0;)c=i[f],c=c>0?c*r+a:a,a=c>>8,i[f]=c%256,f++}for(;f-- >0;)o.push(i[f]);return Uint8Array.from(o)}};class E extends Uint8Array{constructor(t,e=null,n="be"){if(null!==e){const n=new Uint8Array(e).fill(0);n.set(new Uint8Array(t)),t=n.buffer}return super(t="le"===n?new Uint8Array(t).reverse():t),this}toNum(t="le"){return F("le"===t?this.reverse():this)}toBig(t="le"){return B("le"===t?this.reverse():this)}toArr(){return Array.from(this)}toStr(){return S(this)}toHex(){return function(t){const e=[];let n;for(n=0;n<t.length;n++)e.push(t[n].toString(16).padStart(2,"0"));return e.join("")}(this)}toJson(){return JSON.parse(S(this))}toBytes(){return new Uint8Array(this)}toBech32(t,e){return m.encode(this,t,e)}toBase58(){return v.encode(this,"base58")}toBase64(t){return v.encode(this,"base64",t)}toB64url(){return v.encode(this,"base64url")}prepend(t){return E.of(...t,...this)}append(t){return E.of(...this,...t)}slice(t,e){return new E(new Uint8Array(this).slice(t,e))}reverse(){return new E(new Uint8Array(this).reverse())}write(t,e){this.set(t,e)}addVarint(t=this.length){return E.of(...E.getVarint(t),...this)}static from(t){return new E(Uint8Array.from(t))}static of(...t){return new E(Uint8Array.of(...t))}static join(t){let e,n=0;const r=t.reduce(((t,e)=>t+e.length),0),i=new Uint8Array(r);for(const r of t)for(e=0;e<r.length;n++,e++)i[n]=r[e];return new E(i,r)}static getVarint(t){if(t<253)return E.num(t,1);if(t<65536)return E.of(253,...E.num(t,2));if(t<4294967296)return E.of(254,...E.num(t,4));if(t<0x10000000000000000)return E.of(255,...E.num(t,8));throw new Error(`Value is too large: ${t}`)}}function A(t){return(new TextEncoder).encode(t).buffer}function S(t){return(new TextDecoder).decode(t)}function F(t){let e,n=0;for(e=t.length-1;e>=0;e--)n=256*n+t[e];return Number(n)}function B(t){let e,n=0n;for(e=t.length-1;e>=0;e--)n=256n*n+BigInt(t[e]);return BigInt(n)}E.num=(t,e,n="le")=>new E(function(t){const e=[];for(;t>0;){const n=255&t;e.push(n),t=(t-n)/256}return Uint8Array.from(e)}(t),e,n),E.big=(t,e,n="le")=>new E(function(t){const e=[];for(;t>0n;){const n=0xffn&t;e.push(Number(n)),t=(t-n)/256n}return Uint8Array.from(e)}(t),e,n),E.buff=(t,e)=>new E(t,e),E.str=(t,e)=>new E(A(t),e),E.hex=(t,e)=>new E(function(t){const e=[];let n,r=0;if(t.length%2>0)throw new Error(`Invalid hex string length: ${t.length}`);for(n=0;n<t.length;n+=2)e[r]=parseInt(t.slice(n,n+2),16),r+=1;return Uint8Array.from(e).buffer}(t),e),E.json=t=>new E(A(JSON.stringify(t))),E.bech32=(t,e)=>new E(m.decode(t,e)),E.base58=t=>new E(v.decode(t,"base58")),E.base64=t=>new E(v.decode(t,"base64")),E.b64url=t=>new E(v.decode(t,"base64url"));const U={null:t=>null===t,undefined:t=>void 0===t,hex:t=>function(t){switch(!0){case"string"!=typeof t:case/[^0-9a-fA-F]/.test(t):case t.length%2!=0:return!1;default:return!0}}(t),string:t=>"string"==typeof t,infinity:t=>t===1/0,bigint:t=>"bigint"==typeof t,number:t=>"number"==typeof t,class:t=>"object"==typeof t?.prototype&&t.toString().startsWith("class"),function:t=>"function"==typeof t,uint8:t=>t instanceof Uint8Array,uint16:t=>t instanceof Uint16Array,uint32:t=>t instanceof Uint32Array,buffer:t=>t instanceof ArrayBuffer,array:t=>Array.isArray(t),object:t=>"object"==typeof t};var I={of:t=>{for(const[e,n]of Object.entries(U))if(!0===n(t))return e;return"unknown"},array:{isString:t=>t.every((t=>U.string(t))),isNumber:t=>t.every((t=>U.number(t))),isBigint:t=>t.every((t=>U.bigint(t)))},is:U};
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */const P=BigInt(0),R=BigInt(1),T=BigInt(2),_=BigInt(3),H=BigInt(8),k=Object.freeze({a:P,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:R,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")});function C(t){const{a:e,b:n}=k,r=nt(t*t),i=nt(r*t);return nt(i+e*t+n)}const N=k.a===P;class z extends Error{constructor(t){super(t)}}class O{constructor(t,e,n){this.x=t,this.y=e,this.z=n}static fromAffine(t){if(!(t instanceof $))throw new TypeError("JacobianPoint#fromAffine: expected Point");return new O(t.x,t.y,R)}static toAffineBatch(t){const e=function(t,e=k.P){const n=new Array(t.length),r=it(t.reduce(((t,r,i)=>r===P?t:(n[i]=t,nt(t*r,e))),R),e);return t.reduceRight(((t,r,i)=>r===P?t:(n[i]=nt(t*n[i],e),nt(t*r,e))),r),n}(t.map((t=>t.z)));return t.map(((t,n)=>t.toAffine(e[n])))}static normalizeZ(t){return O.toAffineBatch(t).map(O.fromAffine)}equals(t){if(!(t instanceof O))throw new TypeError("JacobianPoint expected");const{x:e,y:n,z:r}=this,{x:i,y:o,z:s}=t,a=nt(r*r),c=nt(s*s),f=nt(e*c),u=nt(i*a),h=nt(nt(n*s)*c),l=nt(nt(o*r)*a);return f===u&&h===l}negate(){return new O(this.x,nt(-this.y),this.z)}double(){const{x:t,y:e,z:n}=this,r=nt(t*t),i=nt(e*e),o=nt(i*i),s=t+i,a=nt(T*(nt(s*s)-r-o)),c=nt(_*r),f=nt(c*c),u=nt(f-T*a),h=nt(c*(a-u)-H*o),l=nt(T*e*n);return new O(u,h,l)}add(t){if(!(t instanceof O))throw new TypeError("JacobianPoint expected");const{x:e,y:n,z:r}=this,{x:i,y:o,z:s}=t;if(i===P||o===P)return this;if(e===P||n===P)return t;const a=nt(r*r),c=nt(s*s),f=nt(e*c),u=nt(i*a),h=nt(nt(n*s)*c),l=nt(nt(o*r)*a),d=nt(u-f),y=nt(l-h);if(d===P)return y===P?this.double():O.ZERO;const g=nt(d*d),w=nt(d*g),p=nt(f*g),m=nt(y*y-w-T*p),b=nt(y*(p-m)-h*w),x=nt(r*s*d);return new O(m,b,x)}subtract(t){return this.add(t.negate())}multiplyUnsafe(t){const e=O.ZERO;if("bigint"==typeof t&&t===P)return e;let n=et(t);if(n===R)return this;if(!N){let t=e,r=this;for(;n>P;)n&R&&(t=t.add(r)),r=r.double(),n>>=R;return t}let{k1neg:r,k1:i,k2neg:o,k2:s}=at(n),a=e,c=e,f=this;for(;i>P||s>P;)i&R&&(a=a.add(f)),s&R&&(c=c.add(f)),f=f.double(),i>>=R,s>>=R;return r&&(a=a.negate()),o&&(c=c.negate()),c=new O(nt(c.x*k.beta),c.y,c.z),a.add(c)}precomputeWindow(t){const e=N?128/t+1:256/t+1,n=[];let r=this,i=r;for(let o=0;o<e;o++){i=r,n.push(i);for(let e=1;e<2**(t-1);e++)i=i.add(r),n.push(i);r=i.double()}return n}wNAF(t,e){!e&&this.equals(O.BASE)&&(e=$.BASE);const n=e&&e._WINDOW_SIZE||1;if(256%n)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let r=e&&q.get(e);r||(r=this.precomputeWindow(n),e&&1!==n&&(r=O.normalizeZ(r),q.set(e,r)));let i=O.ZERO,o=O.ZERO;const s=1+(N?128/n:256/n),a=2**(n-1),c=BigInt(2**n-1),f=2**n,u=BigInt(n);for(let e=0;e<s;e++){const n=e*a;let s=Number(t&c);if(t>>=u,s>a&&(s-=f,t+=R),0===s){let t=r[n];e%2&&(t=t.negate()),o=o.add(t)}else{let t=r[n+Math.abs(s)-1];s<0&&(t=t.negate()),i=i.add(t)}}return{p:i,f:o}}multiply(t,e){let n,r,i=et(t);if(N){const{k1neg:t,k1:o,k2neg:s,k2:a}=at(i);let{p:c,f:f}=this.wNAF(o,e),{p:u,f:h}=this.wNAF(a,e);t&&(c=c.negate()),s&&(u=u.negate()),u=new O(nt(u.x*k.beta),u.y,u.z),n=c.add(u),r=f.add(h)}else{const{p:t,f:o}=this.wNAF(i,e);n=t,r=o}return O.normalizeZ([n,r])[0]}toAffine(t=it(this.z)){const{x:e,y:n,z:r}=this,i=t,o=nt(i*i),s=nt(o*i),a=nt(e*o),c=nt(n*s);if(nt(r*i)!==R)throw new Error("invZ was invalid");return new $(a,c)}}O.BASE=new O(k.Gx,k.Gy,R),O.ZERO=new O(P,R,P);const q=new WeakMap;let $=class{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,q.delete(this)}hasEvenY(){return this.y%T===P}static fromCompressedHex(t){const e=32===t.length,n=Q(e?t:t.subarray(1));if(!dt(n))throw new Error("Point is not on curve");let r=function(t){const{P:e}=k,n=BigInt(6),r=BigInt(11),i=BigInt(22),o=BigInt(23),s=BigInt(44),a=BigInt(88),c=t*t*t%e,f=c*c*t%e,u=rt(f,_)*f%e,h=rt(u,_)*f%e,l=rt(h,T)*c%e,d=rt(l,r)*l%e,y=rt(d,i)*d%e,g=rt(y,s)*y%e,w=rt(g,a)*g%e,p=rt(w,s)*y%e,m=rt(p,_)*f%e,b=rt(m,o)*d%e,x=rt(b,n)*c%e;return rt(x,T)}(C(n));const i=(r&R)===R;if(e)i&&(r=nt(-r));else{1==(1&t[0])!==i&&(r=nt(-r))}const o=new $(n,r);return o.assertValidity(),o}static fromUncompressedHex(t){const e=Q(t.subarray(1,33)),n=Q(t.subarray(33,65)),r=new $(e,n);return r.assertValidity(),r}static fromHex(t){const e=tt(t),n=e.length,r=e[0];if(32===n||33===n&&(2===r||3===r))return this.fromCompressedHex(e);if(65===n&&4===r)return this.fromUncompressedHex(e);throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${n}`)}static fromPrivateKey(t){return $.BASE.multiply(gt(t))}static fromSignature(t,e,n){const r=ct(t=tt(t)),{r:i,s:o}=pt(e);if(0!==n&&1!==n)throw new Error("Cannot recover signature: invalid recovery bit");const s=1&n?"03":"02",a=$.fromHex(s+L(i)),{n:c}=k,f=it(i,c),u=nt(-r*f,c),h=nt(o*f,c),l=$.BASE.multiplyAndAddUnsafe(a,u,h);if(!l)throw new Error("Cannot recover signature: point at infinify");return l.assertValidity(),l}toRawBytes(t=!1){return M(this.toHex(t))}toHex(t=!1){const e=L(this.x);if(t){return`${this.hasEvenY()?"02":"03"}${e}`}return`04${e}${L(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const t="Point is not on elliptic curve",{x:e,y:n}=this;if(!dt(e)||!dt(n))throw new Error(t);const r=nt(n*n);if(nt(r-C(e))!==P)throw new Error(t)}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new $(this.x,nt(-this.y))}double(){return O.fromAffine(this).double().toAffine()}add(t){return O.fromAffine(this).add(O.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return O.fromAffine(this).multiply(t,this).toAffine()}multiplyAndAddUnsafe(t,e,n){const r=O.fromAffine(this),i=e===P||e===R||this!==$.BASE?r.multiplyUnsafe(e):r.multiply(e),o=O.fromAffine(t).multiplyUnsafe(n),s=i.add(o);return s.equals(O.ZERO)?void 0:s.toAffine()}};function j(t){return Number.parseInt(t[0],16)>=8?"00"+t:t}function V(t){if(t.length<2||2!==t[0])throw new Error(`Invalid signature integer tag: ${W(t)}`);const e=t[1],n=t.subarray(2,e+2);if(!e||n.length!==e)throw new Error("Invalid signature integer: wrong length");if(0===n[0]&&n[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:Q(n),left:t.subarray(e+2)}}$.BASE=new $(k.Gx,k.Gy),$.ZERO=new $(P,P);class D{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromCompact(t){const e=t instanceof Uint8Array,n="Signature.fromCompact";if("string"!=typeof t&&!e)throw new TypeError(`${n}: Expected string or Uint8Array`);const r=e?W(t):t;if(128!==r.length)throw new Error(`${n}: Expected 64-byte hex`);return new D(G(r.slice(0,64)),G(r.slice(64,128)))}static fromDER(t){const e=t instanceof Uint8Array;if("string"!=typeof t&&!e)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r:n,s:r}=function(t){if(t.length<2||48!=t[0])throw new Error(`Invalid signature tag: ${W(t)}`);if(t[1]!==t.length-2)throw new Error("Invalid signature: incorrect length");const{data:e,left:n}=V(t.subarray(2)),{data:r,left:i}=V(n);if(i.length)throw new Error(`Invalid signature: left bytes after parsing: ${W(i)}`);return{r:e,s:r}}(e?t:M(t));return new D(n,r)}static fromHex(t){return this.fromDER(t)}assertValidity(){const{r:t,s:e}=this;if(!lt(t))throw new Error("Invalid Signature: r must be 0 < r < n");if(!lt(e))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const t=k.n>>R;return this.s>t}normalizeS(){return this.hasHighS()?new D(this.r,k.n-this.s):this}toDERRawBytes(t=!1){return M(this.toDERHex(t))}toDERHex(t=!1){const e=j(Y(this.s));if(t)return e;const n=j(Y(this.r)),r=Y(n.length/2),i=Y(e.length/2);return`30${Y(n.length/2+e.length/2+4)}02${r}${n}02${i}${e}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return M(this.toCompactHex())}toCompactHex(){return L(this.r)+L(this.s)}}function X(...t){if(!t.every((t=>t instanceof Uint8Array)))throw new Error("Uint8Array list expected");if(1===t.length)return t[0];const e=t.reduce(((t,e)=>t+e.length),0),n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const i=t[e];n.set(i,r),r+=i.length}return n}const K=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function W(t){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");let e="";for(let n=0;n<t.length;n++)e+=K[t[n]];return e}const Z=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function L(t){if("bigint"!=typeof t)throw new Error("Expected bigint");if(!(P<=t&&t<Z))throw new Error("Expected number < 2^256");return t.toString(16).padStart(64,"0")}function J(t){const e=M(L(t));if(32!==e.length)throw new Error("Error: expected 32 bytes");return e}function Y(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function G(t){if("string"!=typeof t)throw new TypeError("hexToNumber: expected string, got "+typeof t);return BigInt(`0x${t}`)}function M(t){if("string"!=typeof t)throw new TypeError("hexToBytes: expected string, got "+typeof t);if(t.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+t.length);const e=new Uint8Array(t.length/2);for(let n=0;n<e.length;n++){const r=2*n,i=t.slice(r,r+2),o=Number.parseInt(i,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");e[n]=o}return e}function Q(t){return G(W(t))}function tt(t){return t instanceof Uint8Array?Uint8Array.from(t):M(t)}function et(t){if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)return BigInt(t);if("bigint"==typeof t&&lt(t))return t;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function nt(t,e=k.P){const n=t%e;return n>=P?n:e+n}function rt(t,e){const{P:n}=k;let r=t;for(;e-- >P;)r*=r,r%=n;return r}function it(t,e=k.P){if(t===P||e<=P)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=nt(t,e),r=e,i=P,o=R;for(;n!==P;){const t=r%n,e=i-o*(r/n);r=n,n=t,i=o,o=e}if(r!==R)throw new Error("invert: does not exist");return nt(i,e)}const ot=(t,e)=>(t+e/T)/e,st={a1:BigInt("0x3086d221a7d46bcde86c90e49284eb15"),b1:-R*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),a2:BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),b2:BigInt("0x3086d221a7d46bcde86c90e49284eb15"),POW_2_128:BigInt("0x100000000000000000000000000000000")};function at(t){const{n:e}=k,{a1:n,b1:r,a2:i,b2:o,POW_2_128:s}=st,a=ot(o*t,e),c=ot(-r*t,e);let f=nt(t-a*n-c*i,e),u=nt(-a*r-c*o,e);const h=f>s,l=u>s;if(h&&(f=e-f),l&&(u=e-u),f>s||u>s)throw new Error("splitScalarEndo: Endomorphism failed, k="+t);return{k1neg:h,k1:f,k2neg:l,k2:u}}function ct(t){const{n:e}=k,n=8*t.length-256;let r=Q(t);return n>0&&(r>>=BigInt(n)),r>=e&&(r-=e),r}let ft,ut;class ht{constructor(){this.v=new Uint8Array(32).fill(1),this.k=new Uint8Array(32).fill(0),this.counter=0}hmac(...t){return Nt.hmacSha256(this.k,...t)}hmacSync(...t){return ut(this.k,...t)}checkSync(){if("function"!=typeof ut)throw new z("hmacSha256Sync needs to be set")}incr(){if(this.counter>=1e3)throw new Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(t=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),t),this.v=await this.hmac(this.v),0!==t.length&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),t),this.v=await this.hmac(this.v))}reseedSync(t=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),t),this.v=this.hmacSync(this.v),0!==t.length&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),t),this.v=this.hmacSync(this.v))}async generate(){return this.incr(),this.v=await this.hmac(this.v),this.v}generateSync(){return this.checkSync(),this.incr(),this.v=this.hmacSync(this.v),this.v}}function lt(t){return P<t&&t<k.n}function dt(t){return P<t&&t<k.P}function yt(t,e,n){const r=Q(t);if(!lt(r))return;const{n:i}=k,o=$.BASE.multiply(r),s=nt(o.x,i);if(s===P)return;const a=nt(it(r,i)*nt(e+n*s,i),i);if(a===P)return;const c=new D(s,a);return{sig:c,recovery:(o.x===c.r?0:2)|Number(o.y&R)}}function gt(t){let e;if("bigint"==typeof t)e=t;else if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)e=BigInt(t);else if("string"==typeof t){if(64!==t.length)throw new Error("Expected 32 bytes of private key");e=G(t)}else{if(!(t instanceof Uint8Array))throw new TypeError("Expected valid private key");if(32!==t.length)throw new Error("Expected 32 bytes of private key");e=Q(t)}if(!lt(e))throw new Error("Expected private key: 0 < key < n");return e}function wt(t){return t instanceof $?(t.assertValidity(),t):$.fromHex(t)}function pt(t){if(t instanceof D)return t.assertValidity(),t;try{return D.fromDER(t)}catch(e){return D.fromCompact(t)}}function mt(t){const e=t instanceof Uint8Array,n="string"==typeof t,r=(e||n)&&t.length;return e?33===r||65===r:n?66===r||130===r:t instanceof $}function bt(t){return Q(t.length>32?t.slice(0,32):t)}function xt(t){const e=bt(t),n=nt(e,k.n);return vt(n<P?e:n)}function vt(t){return J(t)}function Et(t,e,n){if(null==t)throw new Error(`sign: expected valid message hash, not "${t}"`);const r=tt(t),i=gt(e),o=[vt(i),xt(r)];if(null!=n){!0===n&&(n=Nt.randomBytes(32));const t=tt(n);if(32!==t.length)throw new Error("sign: Expected 32 bytes of extra data");o.push(t)}return{seed:X(...o),m:bt(r),d:i}}function At(t,e){let{sig:n,recovery:r}=t;const{canonical:i,der:o,recovered:s}=Object.assign({canonical:!0,der:!0},e);i&&n.hasHighS()&&(n=n.normalizeS(),r^=1);const a=o?n.toDERRawBytes():n.toCompactRawBytes();return s?[a,r]:a}const St={strict:!0};function Ft(t){return nt(Q(t),k.n)}class Bt{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromHex(t){const e=tt(t);if(64!==e.length)throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${e.length}`);const n=Q(e.subarray(0,32)),r=Q(e.subarray(32,64));return new Bt(n,r)}assertValidity(){const{r:t,s:e}=this;if(!dt(t)||!lt(e))throw new Error("Invalid signature")}toHex(){return L(this.r)+L(this.s)}toRawBytes(){return M(this.toHex())}}class Ut{constructor(t,e,n=Nt.randomBytes()){if(null==t)throw new TypeError(`sign: Expected valid message, not "${t}"`);this.m=tt(t);const{x:r,scalar:i}=this.getScalar(gt(e));if(this.px=r,this.d=i,this.rand=tt(n),32!==this.rand.length)throw new TypeError("sign: Expected 32 bytes of aux randomness")}getScalar(t){const e=$.fromPrivateKey(t),n=e.hasEvenY()?t:k.n-t;return{point:e,scalar:n,x:e.toRawX()}}initNonce(t,e){return J(t^Q(e))}finalizeNonce(t){const e=nt(Q(t),k.n);if(e===P)throw new Error("sign: Creation of signature failed. k is zero");const{point:n,x:r,scalar:i}=this.getScalar(e);return{R:n,rx:r,k:i}}finalizeSig(t,e,n,r){return new Bt(t.x,nt(e+n*r,k.n)).toRawBytes()}error(){throw new Error("sign: Invalid signature produced")}async calc(){const{m:t,d:e,px:n,rand:r}=this,i=Nt.taggedHash,o=this.initNonce(e,await i(kt.aux,r)),{R:s,rx:a,k:c}=this.finalizeNonce(await i(kt.nonce,o,n,t)),f=Ft(await i(kt.challenge,a,n,t)),u=this.finalizeSig(s,c,f,e);return await Rt(u,t,n)||this.error(),u}calcSync(){const{m:t,d:e,px:n,rand:r}=this,i=Nt.taggedHashSync,o=this.initNonce(e,i(kt.aux,r)),{R:s,rx:a,k:c}=this.finalizeNonce(i(kt.nonce,o,n,t)),f=Ft(i(kt.challenge,a,n,t)),u=this.finalizeSig(s,c,f,e);return Tt(u,t,n)||this.error(),u}}function It(t,e,n){const r=t instanceof Bt,i=r?t:Bt.fromHex(t);return r&&i.assertValidity(),{...i,m:tt(e),P:wt(n)}}function Pt(t,e,n,r){const i=$.BASE.multiplyAndAddUnsafe(e,gt(n),nt(-r,k.n));return!(!i||!i.hasEvenY()||i.x!==t)}async function Rt(t,e,n){try{const{r:r,s:i,m:o,P:s}=It(t,e,n),a=Ft(await Nt.taggedHash(kt.challenge,J(r),s.toRawX(),o));return Pt(r,s,i,a)}catch(t){return!1}}function Tt(t,e,n){try{const{r:r,s:i,m:o,P:s}=It(t,e,n),a=Ft(Nt.taggedHashSync(kt.challenge,J(r),s.toRawX(),o));return Pt(r,s,i,a)}catch(t){if(t instanceof z)throw t;return!1}}const _t={Signature:Bt,getPublicKey:function(t){return $.fromPrivateKey(t).toRawX()},sign:async function(t,e,n){return new Ut(t,e,n).calc()},verify:Rt,signSync:function(t,e,n){return new Ut(t,e,n).calcSync()},verifySync:Tt};$.BASE._setWindowSize(8);const Ht={node:o,web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},kt={challenge:"BIP0340/challenge",aux:"BIP0340/aux",nonce:"BIP0340/nonce"},Ct={},Nt={bytesToHex:W,hexToBytes:M,concatBytes:X,mod:nt,invert:it,isValidPrivateKey(t){try{return gt(t),!0}catch(t){return!1}},_bigintTo32Bytes:J,_normalizePrivateKey:gt,hashToPrivateKey:t=>{if((t=tt(t)).length<40||t.length>1024)throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");return J(nt(Q(t),k.n-R)+R)},randomBytes:(t=32)=>{if(Ht.web)return Ht.web.getRandomValues(new Uint8Array(t));if(Ht.node){const{randomBytes:e}=Ht.node;return Uint8Array.from(e(t))}throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>Nt.hashToPrivateKey(Nt.randomBytes(40)),sha256:async(...t)=>{if(Ht.web){const e=await Ht.web.subtle.digest("SHA-256",X(...t));return new Uint8Array(e)}if(Ht.node){const{createHash:e}=Ht.node,n=e("sha256");return t.forEach((t=>n.update(t))),Uint8Array.from(n.digest())}throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(t,...e)=>{if(Ht.web){const n=await Ht.web.subtle.importKey("raw",t,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),r=X(...e),i=await Ht.web.subtle.sign("HMAC",n,r);return new Uint8Array(i)}if(Ht.node){const{createHmac:n}=Ht.node,r=n("sha256",t);return e.forEach((t=>r.update(t))),Uint8Array.from(r.digest())}throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(t,...e)=>{let n=Ct[t];if(void 0===n){const e=await Nt.sha256(Uint8Array.from(t,(t=>t.charCodeAt(0))));n=X(e,e),Ct[t]=n}return Nt.sha256(n,...e)},taggedHashSync:(t,...e)=>{if("function"!=typeof ft)throw new z("sha256Sync is undefined, you need to set it");let n=Ct[t];if(void 0===n){const e=ft(Uint8Array.from(t,(t=>t.charCodeAt(0))));n=X(e,e),Ct[t]=n}return ft(n,...e)},precompute(t=8,e=$.BASE){const n=e===$.BASE?e:new $(e.x,e.y);return n._setWindowSize(t),n.multiply(_),n}};Object.defineProperties(Nt,{sha256Sync:{configurable:!1,get:()=>ft,set(t){ft||(ft=t)}},hmacSha256Sync:{configurable:!1,get:()=>ut,set(t){ut||(ut=t)}}});var zt=Object.freeze({__proto__:null,CURVE:k,Point:$,Signature:D,getPublicKey:function(t,e=!1){return $.fromPrivateKey(t).toRawBytes(e)},recoverPublicKey:function(t,e,n,r=!1){return $.fromSignature(t,e,n).toRawBytes(r)},getSharedSecret:function(t,e,n=!1){if(mt(t))throw new TypeError("getSharedSecret: first arg must be private key");if(!mt(e))throw new TypeError("getSharedSecret: second arg must be public key");const r=wt(e);return r.assertValidity(),r.multiply(gt(t)).toRawBytes(n)},sign:async function(t,e,n={}){const{seed:r,m:i,d:o}=Et(t,e,n.extraEntropy);let s;const a=new ht;for(await a.reseed(r);!(s=yt(await a.generate(),i,o));)await a.reseed();return At(s,n)},signSync:function(t,e,n={}){const{seed:r,m:i,d:o}=Et(t,e,n.extraEntropy);let s;const a=new ht;for(a.reseedSync(r);!(s=yt(a.generateSync(),i,o));)a.reseedSync();return At(s,n)},verify:function(t,e,n,r=St){let i;try{i=pt(t),e=tt(e)}catch(t){return!1}const{r:o,s:s}=i;if(r.strict&&i.hasHighS())return!1;const a=ct(e);let c;try{c=wt(n)}catch(t){return!1}const{n:f}=k,u=it(s,f),h=nt(a*u,f),l=nt(o*u,f),d=$.BASE.multiplyAndAddUnsafe(c,h,l);return!!d&&nt(d.x,f)===o},schnorr:_t,utils:Nt});let Ot=class extends Uint8Array{constructor(t){t=t instanceof Uint8Array?E.from(t).toBig():"number"==typeof t?BigInt(t):t,super(t=E.big(Ot.mod(t)))}static mod(t,e=Ot.N){return Nt.mod(t,e)}static fromPrivate(t){if(t<=0)throw new TypeError("Number cannot be negative.");if(t>=Ot.N)throw new TypeError("Number cannot be greater than N: 2**256 - 2**32 - 977");return new Ot(t)}get num(){const t=new Uint8Array(this);return E.buff(t).toBig()}get point(){return qt.fromScalar(this.num)}gt(t){return new Ot(t).num>this.num}lt(t){return new Ot(t).num<this.num}eq(t){return new Ot(t).num===this.num}ne(t){return new Ot(t).num!==this.num}add(t){const e=new Ot(t);return new Ot(this.num+e.num)}sub(t){const e=new Ot(t);return new Ot(this.num-e.num)}mul(t){const e=new Ot(t);return new Ot(this.num*e.num)}pow(t,e=Ot.N-1n){const n=new Ot(t),r=Ot.mod(n.num,e);return new Ot(this.num**r)}div(t){const e=new Ot(t),n=this.pow(e.num,Ot.N-2n);return new Ot(this.num*n.num)}};Ot.N=k.n,Ot.isField=t=>t instanceof Ot;let qt=class{constructor(t,e){this.__p=new $(t,e),this.__x=this.__p.x,this.__y=this.__p.y}static fromScalar(t){const e=t instanceof Uint8Array?E.from(t).toBig():"number"==typeof t?BigInt(t):t,n=Nt.mod(e,qt.N),r=$.BASE.multiply(n);return new qt(r.x,r.y)}static fromX(t){const e=E.buff(t).toHex();return qt.from($.fromHex(e))}static from(t){return new qt(t.x,t.y)}get p(){return this.__p}get rawX(){const t=this.__p.hasEvenY()?2:3,e=E.big(this.__x);return Uint8Array.of(t,...e)}get rawXR(){const t=this.__p.hasEvenY()?2:3,e=E.big(this.__x);return Uint8Array.of(t,...e)}get rawY(){return E.big(this.__y)}get x(){return this.__x}get y(){return this.__y}eq(t){return t instanceof qt?this.p.equals(new $(t.x,t.y)):t instanceof Uint8Array?this.x.toString()===t.toString():"number"==typeof t?BigInt(t)===this.x:t===this.x}add(t){return t instanceof qt?qt.from(this.p.add(t.p)):qt.from(this.p.add(qt.fromScalar(t).p))}sub(t){return t instanceof qt?qt.from(this.p.subtract(t.p)):qt.from(this.p.subtract(qt.fromScalar(t).p))}mul(t){if(t instanceof Uint8Array){const e=E.from(t).toBig();return qt.from(this.p.multiply(e))}return t instanceof qt?qt.from(this.p.multiply(t.x)):qt.from(this.p.multiply(t))}};qt.N=k.n;var $t=Object.freeze({__proto__:null,Field:Ot,Point:qt,Noble:zt});function jt(t=32){return n.webcrypto.getRandomValues(new Uint8Array(t))}const Vt=new TextEncoder,{Field:Dt,Noble:Xt}=$t,Kt=E.hex("80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF");i.pointFromScalar(Kt),Xt.Point.BASE.multiply(BigInt("0x80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF"));const Wt=Dt.fromPrivate(Kt),Zt=Wt.point,Lt=i.pointFromScalar(Kt,!0);if(null===Lt)throw TypeError("Encountered null value!");const Jt=E.buff(Vt.encode("test"),32),Yt=i.sign(Jt,Wt),Gt=i.sign(Jt,Kt),Mt=E.num(150,32),Qt=Wt.add(Mt),te=i.privateAdd(Kt,Mt),ee=Zt.add(Mt),ne=i.pointAddScalar(Lt,Mt,!0),re=i.pointAddScalar(Zt.rawX,Mt,!0);if(null===te||null===ne||null===re)throw TypeError("Encountered null value!");const ie=i.sign(Jt,Qt),oe=i.sign(Jt,te);async function se(t){return async function(t,e="SHA-256",r=1){let i,o=t.buffer;for(i=0;i<r;i++)o=await n.webcrypto.subtle.digest(e,o);return new Uint8Array(o)}(t,"SHA-256")}const{Field:ae,Point:ce}=$t,fe=new TextEncoder;const{Field:ue,Point:he}=$t,le=new TextEncoder;const de=/[\p{Lu}]/u,ye=/[\p{Ll}]/u,ge=/^[\p{Lu}](?![\p{Lu}])/gu,we=/([\p{Alpha}\p{N}_]|$)/u,pe=/[_.\- ]+/,me=new RegExp("^"+pe.source),be=new RegExp(pe.source+we.source,"gu"),xe=new RegExp("\\d+"+we.source,"gu");function ve(t,e){if("string"!=typeof t&&!Array.isArray(t))throw new TypeError("Expected the input to be `string | string[]`");if(e={pascalCase:!1,preserveConsecutiveUppercase:!1,...e},0===(t=Array.isArray(t)?t.map((t=>t.trim())).filter((t=>t.length)).join("-"):t.trim()).length)return"";const n=!1===e.locale?t=>t.toLowerCase():t=>t.toLocaleLowerCase(e.locale),r=!1===e.locale?t=>t.toUpperCase():t=>t.toLocaleUpperCase(e.locale);if(1===t.length)return pe.test(t)?"":e.pascalCase?r(t):n(t);return t!==n(t)&&(t=((t,e,n)=>{let r=!1,i=!1,o=!1;for(let s=0;s<t.length;s++){const a=t[s];r&&de.test(a)?(t=t.slice(0,s)+"-"+t.slice(s),r=!1,o=i,i=!0,s++):i&&o&&ye.test(a)?(t=t.slice(0,s-1)+"-"+t.slice(s-1),o=i,i=!1,r=!0):(r=e(a)===a&&n(a)!==a,o=i,i=n(a)===a&&e(a)!==a)}return t})(t,n,r)),t=t.replace(me,""),t=e.preserveConsecutiveUppercase?((t,e)=>(ge.lastIndex=0,t.replace(ge,(t=>e(t)))))(t,n):n(t),e.pascalCase&&(t=r(t.charAt(0))+t.slice(1)),((t,e)=>(be.lastIndex=0,xe.lastIndex=0,t.replace(be,((t,n)=>e(n))).replace(xe,(t=>e(t)))))(t,r)}var Ee="@cmdcode/crypto-utils";const Ae="../src/index.js";let Se;async function Fe(t){Se=t;const e=ve(String("/"+Ee).split("/").at(-1)),n=await async function(t){if("undefined"!=typeof window)return window[t];const e=process?.argv&&process.argv.length>2?process.argv.slice(2,3):Ae;if(String(e).includes("main"))throw new Error("Unable to run tests on a commonJs module!");return console.log(`Testing package: ${e}`),import("../"+e).then((t=>t.default?t.default:t))}(e);Be(n)}async function Be(t,e=[]){for(const[n,r]of Object.entries(t))if(I.is.class(r)){const t=[...e,n];Ue(r,t),Be(r,t),console.log("Registering tests for class:",n)}else if(I.is.function(r))Ie(n,r,e);else if(I.is.object(r)){Be(r,[...e,n])}}async function Ue(t,e){const n=[...e,"new"];for(const e of Object.getOwnPropertyNames(t.prototype))Ie(e,t,n)}async function Ie(t,e,n){const r=`./src/${n.join("/").toLowerCase()}/${t}.test.js`;import(r).then((t=>{for(const n of Object.keys(t))Se.test(r.split("/").at(-1),(r=>{console.log(`Running ${n} tests:\n`),t[n](r,e)}))})).catch((t=>{t.message.includes("Cannot find module")||console.log(`Failed to import test for: ${r}\n${t}`)}))}t("Crypto-Utils Test Suite",(async t=>{t.test("ECC Tests",(t=>{!function(t){t.test("Testing ECC Primitives",(t=>{t.plan(13),t.deepEqual(new Uint8Array(Wt),new Uint8Array(Kt),"should be equal seed values"),t.deepEqual(Zt.rawX,Lt,"should be equal points"),t.equal(i.verify(Jt,Lt,Yt),!0,"sig1A and K2 should be valid"),t.equal(i.verify(Jt,Zt.rawX,Gt),!0,"sig1B and K1 should be valid"),t.deepEqual(new Uint8Array(Qt),new Uint8Array(te),"our tweaked scalar should match ecc scalar"),t.deepEqual(ee.rawX,ne,"our tweaked point should match ecc point"),t.deepEqual(ne,re,"ecc points should match when tweaking point or scalar"),t.equal(i.verify(Jt,ee.rawX,ie),!0,"T1 should verify signature 2A"),t.equal(i.verify(Jt,ne,ie),!0,"T2 should verify signature 2A"),t.equal(i.verify(Jt,re,ie),!0,"T3 should verify signature 2A"),t.equal(i.verify(Jt,ee.rawX,oe),!0,"T1 should verify signature 2B"),t.equal(i.verify(Jt,ne,oe),!0,"T2 should verify signature 2B"),t.equal(i.verify(Jt,re,oe),!0,"T3 should verify signature 2B")}))}(t),function(t){t.test("Testing ECC Schnorr Signatures",(async t=>{const e=E.hex("3ddd5602285899a946114506157c7997e5444528f3003f6134712147db19b678").toBytes(),n=e.reverse(),r=new Uint8Array(32);r.set(fe.encode("test message"));const i=ae.fromPrivate(e),o=ce.from(i.point),s=ae.fromPrivate(n),a=ce.from(s.point),c=await se(Uint8Array.of(...r,...a.rawX)),f=s.sub(i.mul(c)).point.x,u=a.sub(o.mul(c)).x;t.plan(1),t.equal(f,u,"signature derivations should be equal.")}))}(t),async function(t){t.test("Testing ECC Discrete Log Signatures",(async t=>{const e=new Uint8Array(32),n=new Uint8Array(32);e.set(le.encode("cloudy day")),n.set(le.encode("bitcoin transaction"));const r=ue.fromPrivate(jt(32)),i=he.from(r.point),o=ue.fromPrivate(jt(32)),s=he.from(o.point),a=ue.fromPrivate(jt(32)),c=he.from(a.point),f=await se(Uint8Array.of(...e,...s.rawX)),u=await se(Uint8Array.of(...n,...c.rawX)),h=s.sub(i.mul(f)),l=o.sub(r.mul(f)),d=a.sub(l.mul(u)),y=c.sub(h.mul(u));t.plan(2),t.equal(l.point.x,h.x,"signature proofs should be equal."),t.equal(d.point.x,y.x,"dlc proofs should be equal.")}))}(t)})),t.test("API Crawler Tests",(async t=>{await Fe(t)}))}))}(tape,ecc,crypto);
