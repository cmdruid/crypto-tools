!function(t,e,r){"use strict";function n(t){var e=Object.create(null);return t&&Object.keys(t).forEach((function(r){if("default"!==r){var n=Object.getOwnPropertyDescriptor(t,r);Object.defineProperty(e,r,n.get?n:{enumerable:!0,get:function(){return t[r]}})}})),e.default=t,Object.freeze(e)}var i=n(e),o=n(r);const s=[{name:"base58",charset:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"},{name:"base64",charset:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"},{name:"base64url",charset:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"}];function a(t){for(const e of s)if(e.name===t)return e.charset;throw TypeError("Charset does not exist: "+t)}const c={encode:function(t,e,r=!1){const n=a(e),i=n.length,o=[];let s,c,u,f="",l=0;for(s=0;s<t.length;s++)for(l=0,c=t[s],f+=c>0||(f.length^s)>0?"":"1";l in o||c>0;)u=o[l],u=u>0?256*u+c:c,c=u/i|0,o[l]=u%i,l++;for(;l-- >0;)f+=n[o[l]];return r&&f.length%4>0?f+"=".repeat(4-f.length%4):f},decode:function(t,e){const r=a(e),n=r.length,i=[],o=[];t=t.replace("=","");let s,c,u,f=0;for(s=0;s<t.length;s++){if(f=0,c=r.indexOf(t[s]),c<0)throw new Error(`Character range out of bounds: ${c}`);for(s=c>0||(o.length^s)>0?s:o.push(0);f in i||c>0;)u=i[f],u=u>0?u*n+c:c,c=u>>8,i[f]=u%256,f++}for(;f-- >0;)o.push(i[f]);return Uint8Array.from(o)}},u="qpzry9x8gf2tvdw0s3jn54khce6mua7l",f=[996825010,642813549,513874426,1027748829,705979059],l="bech32",h="bech32m";function y(t){switch(t){case l:return 1;case h:return 734539939;default:throw new Error(`Unrecognized encoding: ${t}`)}}function d(t){let e=1;for(let r=0;r<t.length;++r){const n=e>>25;e=(33554431&e)<<5^t[r];for(let t=0;t<5;++t)(n>>t&1)>0&&(e^=f[t])}return e}function g(t){const e=[];let r;for(r=0;r<t.length;++r)e.push(t.charCodeAt(r)>>5);for(e.push(0),r=0;r<t.length;++r)e.push(31&t.charCodeAt(r));return e}function w(t,e,r,n=!0){const i=[];let o=0,s=0;const a=(1<<r)-1,c=(1<<e+r-1)-1;for(const n of t){if(n<0||n>>e>0)return[];for(o=(o<<e|n)&c,s+=e;s>=r;)s-=r,i.push(o>>s&a)}if(n)s>0&&i.push(o<<r-s&a);else if(s>=e||(o<<r-s&a)>0)return[];return i}function p(t,e,r){const n=e.concat(function(t,e,r){const n=d(g(t).concat(e).concat([0,0,0,0,0,0]))^y(r),i=[];for(let t=0;t<6;++t)i.push(n>>5*(5-t)&31);return i}(t,e,r));let i=t+"1";for(let t=0;t<n.length;++t)i+=u.charAt(n[t]);return i}function m(t,e){const r=e>0?"bech32m":"bech32";if(!function(t){let e,r,n=!1,i=!1;for(e=0;e<t.length;++e){if(r=t.charCodeAt(e),r<33||r>126)return!1;r>=97&&r<=122&&(n=!0),r>=65&&r<=90&&(i=!0)}return!(n&&i)}(t))return{hrp:null,data:[255]};if(!function(t){const e=t.lastIndexOf("1");return!(e<1||e+7>t.length||t.length>90)}(t=t.toLowerCase()))return{hrp:null,data:[255]};const n=[],i=t.lastIndexOf("1"),o=t.substring(0,i);for(let e=i+1;e<t.length;++e){const r=u.indexOf(t.charAt(e));if(-1===r)return{hrp:null,data:[255]};n.push(r)}return function(t,e,r){return d(g(t).concat(e))===y(r)}(o,n,r)?{hrp:o,data:n.slice(0,n.length-6)}:{hrp:null,data:[255]}}function b(t,e=0){const r=t.split("1",1)[0],{hrp:n,data:i}=m(t,e),o=w(i.slice(1),5,8,!1),s=o.length;switch(!0){case r!==n:throw new Error("Returned hrp string is invalid.");case null===o||s<2||s>40:throw new Error("Decoded string is invalid or out of spec.");case i[0]>16:throw new Error("Returned version bit is out of range.");case 0===i[0]&&20!==s&&32!==s:throw new Error("Decoded string does not match version 0 spec.");case 0===i[0]&&0!==e:case 0!==i[0]&&1!==e:throw new Error("Decoded version bit does not match.");default:return Uint8Array.from(o)}}const v={encode:function(t,e="bch",r=0){const n=p(e,[r,...w([...t],8,5)],r>0?"bech32m":"bech32");return b(n,r),n},decode:b};function x(t){return(new TextEncoder).encode(t).buffer}function A(t){return(new TextDecoder).decode(t)}function E(t){let e,r=0;for(e=t.length-1;e>=0;e--)r=256*r+t[e];return Number(r)}function S(t){let e,r=0n;for(e=t.length-1;e>=0;e--)r=256n*r+BigInt(t[e]);return BigInt(r)}class B extends Uint8Array{constructor(t,e=null,r="be"){if(null!==e){const r=new Uint8Array(e).fill(0);r.set(new Uint8Array(t)),t=r.buffer}return super(t="le"===r?new Uint8Array(t).reverse():t),this}toNum(t="le"){return E("le"===t?this.reverse():this)}toBig(t="le"){return S("le"===t?this.reverse():this)}toArr(){return Array.from(this)}toStr(){return A(this)}toHex(){return function(t){const e=[];let r;for(r=0;r<t.length;r++)e.push(t[r].toString(16).padStart(2,"0"));return e.join("")}(this)}toJson(){return JSON.parse(A(this))}toBytes(){return new Uint8Array(this)}toBase58(){return c.encode(this,"base58")}toB64url(){return c.encode(this,"base64url")}toBech32(t,e){return v.encode(this,t,e)}toBase64(t){return c.encode(this,"base64",t)}prepend(t){return B.of(...t,...this)}append(t){return B.of(...this,...t)}slice(t,e){return new B(new Uint8Array(this).slice(t,e))}reverse(){return new B(new Uint8Array(this).reverse())}write(t,e){this.set(t,e)}addVarint(t=this.length){return B.of(...B.getVarint(t),...this)}static from(t){return new B(Uint8Array.from(t))}static of(...t){return new B(Uint8Array.of(...t))}static join(t){let e,r=0;const n=t.reduce(((t,e)=>t+e.length),0),i=new Uint8Array(n);for(const n of t)for(e=0;e<n.length;r++,e++)i[r]=n[e];return new B(i,n)}static getVarint(t){if(t<253)return B.num(t,1);if(t<65536)return B.of(253,...B.num(t,2));if(t<4294967296)return B.of(254,...B.num(t,4));if(t<0x10000000000000000)return B.of(255,...B.num(t,8));throw new Error(`Value is too large: ${t}`)}static random(t=32){return new B(crypto.getRandomValues(new Uint8Array(t)))}static normalizeBytes(t,e){if("string"==typeof t)return B.hex(t,e).toBytes();if("number"==typeof t)return B.num(t,e).toBytes();if("bigint"==typeof t)return B.big(t,e).toBytes();if(t instanceof Uint8Array)return B.buff(t,e).toBytes();throw TypeError("Unrecognized format: "+typeof t)}static normalizeData(t){if("string"==typeof t)return B.str(t).toBytes();if("object"==typeof t){if(t instanceof Uint8Array)return t;try{return B.json(t).toBytes()}catch{throw TypeError("Object is not serializable.")}}throw TypeError("Unrecognized format: "+typeof t)}}B.num=(t,e,r="le")=>new B(function(t){const e=[];for(;t>0;){const r=255&t;e.push(r),t=(t-r)/256}return Uint8Array.from(e)}(t),e,r),B.big=(t,e,r="le")=>new B(function(t){const e=[];for(;t>0n;){const r=0xffn&t;e.push(Number(r)),t=(t-r)/256n}return Uint8Array.from(e)}(t),e,r),B.buff=(t,e)=>new B(t,e),B.str=(t,e)=>new B(x(t),e),B.hex=(t,e)=>new B(function(t){const e=[];let r,n=0;if(t.length%2>0)throw new Error(`Invalid hex string length: ${t.length}`);for(r=0;r<t.length;r+=2)e[n]=parseInt(t.slice(r,r+2),16),n+=1;return Uint8Array.from(e).buffer}(t),e),B.json=t=>new B(x(JSON.stringify(t))),B.bech32=(t,e)=>new B(v.decode(t,e)),B.base58=t=>new B(c.decode(t,"base58")),B.base64=t=>new B(c.decode(t,"base64")),B.b64url=t=>new B(c.decode(t,"base64url"));const F={null:t=>null===t,undefined:t=>void 0===t,hex:t=>function(t){switch(!0){case"string"!=typeof t:case/[^0-9a-fA-F]/.test(t):case t.length%2!=0:return!1;default:return!0}}(t),string:t=>"string"==typeof t,infinity:t=>t===1/0,bigint:t=>"bigint"==typeof t,number:t=>"number"==typeof t,class:t=>"object"==typeof t?.prototype&&t.toString().startsWith("class"),function:t=>"function"==typeof t,uint8:t=>t instanceof Uint8Array,uint16:t=>t instanceof Uint16Array,uint32:t=>t instanceof Uint32Array,buffer:t=>t instanceof ArrayBuffer,array:t=>Array.isArray(t),object:t=>"object"==typeof t};const U=F,I=BigInt(0),P=BigInt(1),H=BigInt(2),T=BigInt(3),C=BigInt(8),k=Object.freeze({a:I,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:P,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")});
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */function z(t){const{a:e,b:r}=k,n=et(t*t),i=et(n*t);return et(i+e*t+r)}const R=k.a===I;class q extends Error{constructor(t){super(t)}}class _{constructor(t,e,r){this.x=t,this.y=e,this.z=r}static fromAffine(t){if(!(t instanceof K))throw new TypeError("JacobianPoint#fromAffine: expected Point");return new _(t.x,t.y,P)}static toAffineBatch(t){const e=function(t,e=k.P){const r=new Array(t.length),n=nt(t.reduce(((t,n,i)=>n===I?t:(r[i]=t,et(t*n,e))),P),e);return t.reduceRight(((t,n,i)=>n===I?t:(r[i]=et(t*r[i],e),et(t*n,e))),n),r}(t.map((t=>t.z)));return t.map(((t,r)=>t.toAffine(e[r])))}static normalizeZ(t){return _.toAffineBatch(t).map(_.fromAffine)}equals(t){if(!(t instanceof _))throw new TypeError("JacobianPoint expected");const{x:e,y:r,z:n}=this,{x:i,y:o,z:s}=t,a=et(n*n),c=et(s*s),u=et(e*c),f=et(i*a),l=et(et(r*s)*c),h=et(et(o*n)*a);return u===f&&l===h}negate(){return new _(this.x,et(-this.y),this.z)}double(){const{x:t,y:e,z:r}=this,n=et(t*t),i=et(e*e),o=et(i*i),s=t+i,a=et(H*(et(s*s)-n-o)),c=et(T*n),u=et(c*c),f=et(u-H*a),l=et(c*(a-f)-C*o),h=et(H*e*r);return new _(f,l,h)}add(t){if(!(t instanceof _))throw new TypeError("JacobianPoint expected");const{x:e,y:r,z:n}=this,{x:i,y:o,z:s}=t;if(i===I||o===I)return this;if(e===I||r===I)return t;const a=et(n*n),c=et(s*s),u=et(e*c),f=et(i*a),l=et(et(r*s)*c),h=et(et(o*n)*a),y=et(f-u),d=et(h-l);if(y===I)return d===I?this.double():_.ZERO;const g=et(y*y),w=et(y*g),p=et(u*g),m=et(d*d-w-H*p),b=et(d*(p-m)-l*w),v=et(n*s*y);return new _(m,b,v)}subtract(t){return this.add(t.negate())}multiplyUnsafe(t){const e=_.ZERO;if("bigint"==typeof t&&t===I)return e;let r=tt(t);if(r===P)return this;if(!R){let t=e,n=this;for(;r>I;)r&P&&(t=t.add(n)),n=n.double(),r>>=P;return t}let{k1neg:n,k1:i,k2neg:o,k2:s}=st(r),a=e,c=e,u=this;for(;i>I||s>I;)i&P&&(a=a.add(u)),s&P&&(c=c.add(u)),u=u.double(),i>>=P,s>>=P;return n&&(a=a.negate()),o&&(c=c.negate()),c=new _(et(c.x*k.beta),c.y,c.z),a.add(c)}precomputeWindow(t){const e=R?128/t+1:256/t+1,r=[];let n=this,i=n;for(let o=0;o<e;o++){i=n,r.push(i);for(let e=1;e<2**(t-1);e++)i=i.add(n),r.push(i);n=i.double()}return r}wNAF(t,e){!e&&this.equals(_.BASE)&&(e=K.BASE);const r=e&&e._WINDOW_SIZE||1;if(256%r)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let n=e&&N.get(e);n||(n=this.precomputeWindow(r),e&&1!==r&&(n=_.normalizeZ(n),N.set(e,n)));let i=_.ZERO,o=_.ZERO;const s=1+(R?128/r:256/r),a=2**(r-1),c=BigInt(2**r-1),u=2**r,f=BigInt(r);for(let e=0;e<s;e++){const r=e*a;let s=Number(t&c);if(t>>=f,s>a&&(s-=u,t+=P),0===s){let t=n[r];e%2&&(t=t.negate()),o=o.add(t)}else{let t=n[r+Math.abs(s)-1];s<0&&(t=t.negate()),i=i.add(t)}}return{p:i,f:o}}multiply(t,e){let r,n,i=tt(t);if(R){const{k1neg:t,k1:o,k2neg:s,k2:a}=st(i);let{p:c,f:u}=this.wNAF(o,e),{p:f,f:l}=this.wNAF(a,e);t&&(c=c.negate()),s&&(f=f.negate()),f=new _(et(f.x*k.beta),f.y,f.z),r=c.add(f),n=u.add(l)}else{const{p:t,f:o}=this.wNAF(i,e);r=t,n=o}return _.normalizeZ([r,n])[0]}toAffine(t=nt(this.z)){const{x:e,y:r,z:n}=this,i=t,o=et(i*i),s=et(o*i),a=et(e*o),c=et(r*s);if(et(n*i)!==P)throw new Error("invZ was invalid");return new K(a,c)}}_.BASE=new _(k.Gx,k.Gy,P),_.ZERO=new _(I,P,I);const N=new WeakMap;let K=class{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,N.delete(this)}hasEvenY(){return this.y%H===I}static fromCompressedHex(t){const e=32===t.length,r=M(e?t:t.subarray(1));if(!ht(r))throw new Error("Point is not on curve");let n=function(t){const{P:e}=k,r=BigInt(6),n=BigInt(11),i=BigInt(22),o=BigInt(23),s=BigInt(44),a=BigInt(88),c=t*t*t%e,u=c*c*t%e,f=rt(u,T)*u%e,l=rt(f,T)*u%e,h=rt(l,H)*c%e,y=rt(h,n)*h%e,d=rt(y,i)*y%e,g=rt(d,s)*d%e,w=rt(g,a)*g%e,p=rt(w,s)*d%e,m=rt(p,T)*u%e,b=rt(m,o)*y%e,v=rt(b,r)*c%e;return rt(v,H)}(z(r));const i=(n&P)===P;if(e)i&&(n=et(-n));else{1==(1&t[0])!==i&&(n=et(-n))}const o=new K(r,n);return o.assertValidity(),o}static fromUncompressedHex(t){const e=M(t.subarray(1,33)),r=M(t.subarray(33,65)),n=new K(e,r);return n.assertValidity(),n}static fromHex(t){const e=Q(t),r=e.length,n=e[0];if(32===r||33===r&&(2===n||3===n))return this.fromCompressedHex(e);if(65===r&&4===n)return this.fromUncompressedHex(e);throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${r}`)}static fromPrivateKey(t){return K.BASE.multiply(dt(t))}static fromSignature(t,e,r){const n=at(t=Q(t)),{r:i,s:o}=wt(e);if(0!==r&&1!==r)throw new Error("Cannot recover signature: invalid recovery bit");const s=1&r?"03":"02",a=K.fromHex(s+Z(i)),{n:c}=k,u=nt(i,c),f=et(-n*u,c),l=et(o*u,c),h=K.BASE.multiplyAndAddUnsafe(a,f,l);if(!h)throw new Error("Cannot recover signature: point at infinify");return h.assertValidity(),h}toRawBytes(t=!1){return G(this.toHex(t))}toHex(t=!1){const e=Z(this.x);if(t){return`${this.hasEvenY()?"02":"03"}${e}`}return`04${e}${Z(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const t="Point is not on elliptic curve",{x:e,y:r}=this;if(!ht(e)||!ht(r))throw new Error(t);const n=et(r*r);if(et(n-z(e))!==I)throw new Error(t)}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new K(this.x,et(-this.y))}double(){return _.fromAffine(this).double().toAffine()}add(t){return _.fromAffine(this).add(_.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return _.fromAffine(this).multiply(t,this).toAffine()}multiplyAndAddUnsafe(t,e,r){const n=_.fromAffine(this),i=e===I||e===P||this!==K.BASE?n.multiplyUnsafe(e):n.multiply(e),o=_.fromAffine(t).multiplyUnsafe(r),s=i.add(o);return s.equals(_.ZERO)?void 0:s.toAffine()}};function O(t){return Number.parseInt(t[0],16)>=8?"00"+t:t}function $(t){if(t.length<2||2!==t[0])throw new Error(`Invalid signature integer tag: ${X(t)}`);const e=t[1],r=t.subarray(2,e+2);if(!e||r.length!==e)throw new Error("Invalid signature integer: wrong length");if(0===r[0]&&r[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:M(r),left:t.subarray(e+2)}}K.BASE=new K(k.Gx,k.Gy),K.ZERO=new K(I,I);class j{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromCompact(t){const e=t instanceof Uint8Array,r="Signature.fromCompact";if("string"!=typeof t&&!e)throw new TypeError(`${r}: Expected string or Uint8Array`);const n=e?X(t):t;if(128!==n.length)throw new Error(`${r}: Expected 64-byte hex`);return new j(Y(n.slice(0,64)),Y(n.slice(64,128)))}static fromDER(t){const e=t instanceof Uint8Array;if("string"!=typeof t&&!e)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r:r,s:n}=function(t){if(t.length<2||48!=t[0])throw new Error(`Invalid signature tag: ${X(t)}`);if(t[1]!==t.length-2)throw new Error("Invalid signature: incorrect length");const{data:e,left:r}=$(t.subarray(2)),{data:n,left:i}=$(r);if(i.length)throw new Error(`Invalid signature: left bytes after parsing: ${X(i)}`);return{r:e,s:n}}(e?t:G(t));return new j(r,n)}static fromHex(t){return this.fromDER(t)}assertValidity(){const{r:t,s:e}=this;if(!lt(t))throw new Error("Invalid Signature: r must be 0 < r < n");if(!lt(e))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const t=k.n>>P;return this.s>t}normalizeS(){return this.hasHighS()?new j(this.r,k.n-this.s):this}toDERRawBytes(t=!1){return G(this.toDERHex(t))}toDERHex(t=!1){const e=O(J(this.s));if(t)return e;const r=O(J(this.r)),n=J(r.length/2),i=J(e.length/2);return`30${J(r.length/2+e.length/2+4)}02${n}${r}02${i}${e}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return G(this.toCompactHex())}toCompactHex(){return Z(this.r)+Z(this.s)}}function D(...t){if(!t.every((t=>t instanceof Uint8Array)))throw new Error("Uint8Array list expected");if(1===t.length)return t[0];const e=t.reduce(((t,e)=>t+e.length),0),r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const i=t[e];r.set(i,n),n+=i.length}return r}const V=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function X(t){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");let e="";for(let r=0;r<t.length;r++)e+=V[t[r]];return e}const W=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function Z(t){if("bigint"!=typeof t)throw new Error("Expected bigint");if(!(I<=t&&t<W))throw new Error("Expected number < 2^256");return t.toString(16).padStart(64,"0")}function L(t){const e=G(Z(t));if(32!==e.length)throw new Error("Error: expected 32 bytes");return e}function J(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function Y(t){if("string"!=typeof t)throw new TypeError("hexToNumber: expected string, got "+typeof t);return BigInt(`0x${t}`)}function G(t){if("string"!=typeof t)throw new TypeError("hexToBytes: expected string, got "+typeof t);if(t.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+t.length);const e=new Uint8Array(t.length/2);for(let r=0;r<e.length;r++){const n=2*r,i=t.slice(n,n+2),o=Number.parseInt(i,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");e[r]=o}return e}function M(t){return Y(X(t))}function Q(t){return t instanceof Uint8Array?Uint8Array.from(t):G(t)}function tt(t){if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)return BigInt(t);if("bigint"==typeof t&&lt(t))return t;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function et(t,e=k.P){const r=t%e;return r>=I?r:e+r}function rt(t,e){const{P:r}=k;let n=t;for(;e-- >I;)n*=n,n%=r;return n}function nt(t,e=k.P){if(t===I||e<=I)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let r=et(t,e),n=e,i=I,o=P;for(;r!==I;){const t=n%r,e=i-o*(n/r);n=r,r=t,i=o,o=e}if(n!==P)throw new Error("invert: does not exist");return et(i,e)}const it=(t,e)=>(t+e/H)/e,ot={a1:BigInt("0x3086d221a7d46bcde86c90e49284eb15"),b1:-P*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),a2:BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),b2:BigInt("0x3086d221a7d46bcde86c90e49284eb15"),POW_2_128:BigInt("0x100000000000000000000000000000000")};function st(t){const{n:e}=k,{a1:r,b1:n,a2:i,b2:o,POW_2_128:s}=ot,a=it(o*t,e),c=it(-n*t,e);let u=et(t-a*r-c*i,e),f=et(-a*n-c*o,e);const l=u>s,h=f>s;if(l&&(u=e-u),h&&(f=e-f),u>s||f>s)throw new Error("splitScalarEndo: Endomorphism failed, k="+t);return{k1neg:l,k1:u,k2neg:h,k2:f}}function at(t){const{n:e}=k,r=8*t.length-256;let n=M(t);return r>0&&(n>>=BigInt(r)),n>=e&&(n-=e),n}let ct,ut;class ft{constructor(){this.v=new Uint8Array(32).fill(1),this.k=new Uint8Array(32).fill(0),this.counter=0}hmac(...t){return qt.hmacSha256(this.k,...t)}hmacSync(...t){return ut(this.k,...t)}checkSync(){if("function"!=typeof ut)throw new q("hmacSha256Sync needs to be set")}incr(){if(this.counter>=1e3)throw new Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(t=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),t),this.v=await this.hmac(this.v),0!==t.length&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),t),this.v=await this.hmac(this.v))}reseedSync(t=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),t),this.v=this.hmacSync(this.v),0!==t.length&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),t),this.v=this.hmacSync(this.v))}async generate(){return this.incr(),this.v=await this.hmac(this.v),this.v}generateSync(){return this.checkSync(),this.incr(),this.v=this.hmacSync(this.v),this.v}}function lt(t){return I<t&&t<k.n}function ht(t){return I<t&&t<k.P}function yt(t,e,r){const n=M(t);if(!lt(n))return;const{n:i}=k,o=K.BASE.multiply(n),s=et(o.x,i);if(s===I)return;const a=et(nt(n,i)*et(e+r*s,i),i);if(a===I)return;const c=new j(s,a);return{sig:c,recovery:(o.x===c.r?0:2)|Number(o.y&P)}}function dt(t){let e;if("bigint"==typeof t)e=t;else if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)e=BigInt(t);else if("string"==typeof t){if(64!==t.length)throw new Error("Expected 32 bytes of private key");e=Y(t)}else{if(!(t instanceof Uint8Array))throw new TypeError("Expected valid private key");if(32!==t.length)throw new Error("Expected 32 bytes of private key");e=M(t)}if(!lt(e))throw new Error("Expected private key: 0 < key < n");return e}function gt(t){return t instanceof K?(t.assertValidity(),t):K.fromHex(t)}function wt(t){if(t instanceof j)return t.assertValidity(),t;try{return j.fromDER(t)}catch(e){return j.fromCompact(t)}}function pt(t,e=!1){return K.fromPrivateKey(t).toRawBytes(e)}function mt(t){const e=t instanceof Uint8Array,r="string"==typeof t,n=(e||r)&&t.length;return e?33===n||65===n:r?66===n||130===n:t instanceof K}function bt(t){return M(t.length>32?t.slice(0,32):t)}function vt(t){const e=bt(t),r=et(e,k.n);return xt(r<I?e:r)}function xt(t){return L(t)}async function At(t,e,r={}){const{seed:n,m:i,d:o}=function(t,e,r){if(null==t)throw new Error(`sign: expected valid message hash, not "${t}"`);const n=Q(t),i=dt(e),o=[xt(i),vt(n)];if(null!=r){!0===r&&(r=qt.randomBytes(32));const t=Q(r);if(32!==t.length)throw new Error("sign: Expected 32 bytes of extra data");o.push(t)}return{seed:D(...o),m:bt(n),d:i}}(t,e,r.extraEntropy);let s;const a=new ft;for(await a.reseed(n);!(s=yt(await a.generate(),i,o));)await a.reseed();return function(t,e){let{sig:r,recovery:n}=t;const{canonical:i,der:o,recovered:s}=Object.assign({canonical:!0,der:!0},e);i&&r.hasHighS()&&(r=r.normalizeS(),n^=1);const a=o?r.toDERRawBytes():r.toCompactRawBytes();return s?[a,n]:a}(s,r)}const Et={strict:!0};function St(t,e,r,n=Et){let i;try{i=wt(t),e=Q(e)}catch(t){return!1}const{r:o,s:s}=i;if(n.strict&&i.hasHighS())return!1;const a=at(e);let c;try{c=gt(r)}catch(t){return!1}const{n:u}=k,f=nt(s,u),l=et(a*f,u),h=et(o*f,u),y=K.BASE.multiplyAndAddUnsafe(c,l,h);if(!y)return!1;return et(y.x,u)===o}function Bt(t){return et(M(t),k.n)}class Ft{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromHex(t){const e=Q(t);if(64!==e.length)throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${e.length}`);const r=M(e.subarray(0,32)),n=M(e.subarray(32,64));return new Ft(r,n)}assertValidity(){const{r:t,s:e}=this;if(!ht(t)||!lt(e))throw new Error("Invalid signature")}toHex(){return Z(this.r)+Z(this.s)}toRawBytes(){return G(this.toHex())}}class Ut{constructor(t,e,r=qt.randomBytes()){if(null==t)throw new TypeError(`sign: Expected valid message, not "${t}"`);this.m=Q(t);const{x:n,scalar:i}=this.getScalar(dt(e));if(this.px=n,this.d=i,this.rand=Q(r),32!==this.rand.length)throw new TypeError("sign: Expected 32 bytes of aux randomness")}getScalar(t){const e=K.fromPrivateKey(t),r=e.hasEvenY()?t:k.n-t;return{point:e,scalar:r,x:e.toRawX()}}initNonce(t,e){return L(t^M(e))}finalizeNonce(t){const e=et(M(t),k.n);if(e===I)throw new Error("sign: Creation of signature failed. k is zero");const{point:r,x:n,scalar:i}=this.getScalar(e);return{R:r,rx:n,k:i}}finalizeSig(t,e,r,n){return new Ft(t.x,et(e+r*n,k.n)).toRawBytes()}error(){throw new Error("sign: Invalid signature produced")}async calc(){const{m:t,d:e,px:r,rand:n}=this,i=qt.taggedHash,o=this.initNonce(e,await i(zt.aux,n)),{R:s,rx:a,k:c}=this.finalizeNonce(await i(zt.nonce,o,r,t)),u=Bt(await i(zt.challenge,a,r,t)),f=this.finalizeSig(s,c,u,e);return await Ht(f,t,r)||this.error(),f}calcSync(){const{m:t,d:e,px:r,rand:n}=this,i=qt.taggedHashSync,o=this.initNonce(e,i(zt.aux,n)),{R:s,rx:a,k:c}=this.finalizeNonce(i(zt.nonce,o,r,t)),u=Bt(i(zt.challenge,a,r,t)),f=this.finalizeSig(s,c,u,e);return Tt(f,t,r)||this.error(),f}}function It(t,e,r){const n=t instanceof Ft,i=n?t:Ft.fromHex(t);return n&&i.assertValidity(),{...i,m:Q(e),P:gt(r)}}function Pt(t,e,r,n){const i=K.BASE.multiplyAndAddUnsafe(e,dt(r),et(-n,k.n));return!(!i||!i.hasEvenY()||i.x!==t)}async function Ht(t,e,r){try{const{r:n,s:i,m:o,P:s}=It(t,e,r),a=Bt(await qt.taggedHash(zt.challenge,L(n),s.toRawX(),o));return Pt(n,s,i,a)}catch(t){return!1}}function Tt(t,e,r){try{const{r:n,s:i,m:o,P:s}=It(t,e,r),a=Bt(qt.taggedHashSync(zt.challenge,L(n),s.toRawX(),o));return Pt(n,s,i,a)}catch(t){if(t instanceof q)throw t;return!1}}const Ct={Signature:Ft,getPublicKey:function(t){return K.fromPrivateKey(t).toRawX()},sign:async function(t,e,r){return new Ut(t,e,r).calc()},verify:Ht,signSync:function(t,e,r){return new Ut(t,e,r).calcSync()},verifySync:Tt};K.BASE._setWindowSize(8);const kt={node:i,web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},zt={challenge:"BIP0340/challenge",aux:"BIP0340/aux",nonce:"BIP0340/nonce"},Rt={},qt={bytesToHex:X,hexToBytes:G,concatBytes:D,mod:et,invert:nt,isValidPrivateKey(t){try{return dt(t),!0}catch(t){return!1}},_bigintTo32Bytes:L,_normalizePrivateKey:dt,hashToPrivateKey:t=>{if((t=Q(t)).length<40||t.length>1024)throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");return L(et(M(t),k.n-P)+P)},randomBytes:(t=32)=>{if(kt.web)return kt.web.getRandomValues(new Uint8Array(t));if(kt.node){const{randomBytes:e}=kt.node;return Uint8Array.from(e(t))}throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>qt.hashToPrivateKey(qt.randomBytes(40)),sha256:async(...t)=>{if(kt.web){const e=await kt.web.subtle.digest("SHA-256",D(...t));return new Uint8Array(e)}if(kt.node){const{createHash:e}=kt.node,r=e("sha256");return t.forEach((t=>r.update(t))),Uint8Array.from(r.digest())}throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(t,...e)=>{if(kt.web){const r=await kt.web.subtle.importKey("raw",t,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),n=D(...e),i=await kt.web.subtle.sign("HMAC",r,n);return new Uint8Array(i)}if(kt.node){const{createHmac:r}=kt.node,n=r("sha256",t);return e.forEach((t=>n.update(t))),Uint8Array.from(n.digest())}throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(t,...e)=>{let r=Rt[t];if(void 0===r){const e=await qt.sha256(Uint8Array.from(t,(t=>t.charCodeAt(0))));r=D(e,e),Rt[t]=r}return qt.sha256(r,...e)},taggedHashSync:(t,...e)=>{if("function"!=typeof ct)throw new q("sha256Sync is undefined, you need to set it");let r=Rt[t];if(void 0===r){const e=ct(Uint8Array.from(t,(t=>t.charCodeAt(0))));r=D(e,e),Rt[t]=r}return ct(r,...e)},precompute(t=8,e=K.BASE){const r=e===K.BASE?e:new K(e.x,e.y);return r._setWindowSize(t),r.multiply(T),r}};async function _t(t,e){return function(t,e,r=!1){if(mt(t))throw new TypeError("getSharedSecret: first arg must be private key");if(!mt(e))throw new TypeError("getSharedSecret: second arg must be public key");const n=gt(e);return n.assertValidity(),n.multiply(dt(t)).toRawBytes(r)}(B.normalizeBytes(t),B.normalizeBytes(e),!0)}async function Nt(t){return crypto.subtle.importKey("raw",t,{name:"AES-CBC"},!0,["encrypt","decrypt"])}Object.defineProperties(qt,{sha256Sync:{configurable:!1,get:()=>ct,set(t){ct||(ct=t)}},hmacSha256Sync:{configurable:!1,get:()=>ut,set(t){ut||(ut=t)}}});const Kt={crypto:Nt,hmac:async function(t,e="SHA-256"){const r={name:"HMAC",hash:e};return crypto.subtle.importKey("raw",t,r,!1,["sign","verify"])},shared:async function(t,e){return Nt((await _t(t,e)).slice(1,33))},generate:async function(){return Nt(B.random(32))}},Ot={crypto:async function(t){return crypto.subtle.exportKey("raw",t).then((t=>new Uint8Array(t)))}};class $t{constructor(t){this.key=t}static async fromSecret(t){const e=B.normalizeBytes(t),r=await Kt.crypto(e);return new $t(r)}static async fromShared(t,e){const r=await Kt.shared(t,e);return new $t(r)}static async encrypt(t,e,r){const n=r??crypto.getRandomValues(new Uint8Array(16));return crypto.subtle.encrypt({name:"AES-CBC",iv:n},t,e).then((t=>Uint8Array.of(...n,...new Uint8Array(t))))}static async decrypt(t,e){return crypto.subtle.decrypt({name:"AES-CBC",iv:e.slice(0,16)},t,e.slice(16)).then((t=>new Uint8Array(t)))}get secretKey(){return Ot.crypto(this.key)}get secretHex(){return this.secretKey.then((t=>B.buff(t).toHex()))}async encrypt(t,e){return $t.encrypt(this.key,t,e)}async decrypt(t){return $t.decrypt(this.key,t)}}let jt=class extends Uint8Array{constructor(t){t=t instanceof Uint8Array?B.from(t).toBig():"number"==typeof t?BigInt(t):t,super(t=B.big(jt.mod(t),32))}static mod(t,e=jt.N){return qt.mod(t,e)}static fromPrivate(t){if(t<=0)throw new TypeError("Number cannot be negative.");if(t>=jt.N)throw new TypeError("Number cannot be greater than N: 2**256 - 2**32 - 977");return new jt(t)}get num(){const t=new Uint8Array(this);return B.buff(t).toBig()}get point(){return Dt.fromScalar(this.num)}gt(t){return new jt(t).num>this.num}lt(t){return new jt(t).num<this.num}eq(t){return new jt(t).num===this.num}ne(t){return new jt(t).num!==this.num}add(t){const e=new jt(t);return new jt(this.num+e.num)}sub(t){const e=new jt(t);return new jt(this.num-e.num)}mul(t){const e=new jt(t);return new jt(this.num*e.num)}pow(t,e=jt.N-1n){const r=new jt(t),n=jt.mod(r.num,e);return new jt(this.num**n)}div(t){const e=new jt(t),r=this.pow(e.num,jt.N-2n);return new jt(this.num*r.num)}};jt.N=k.n,jt.isField=t=>t instanceof jt;let Dt=class{constructor(t,e){this.__p=new K(t,e),this.__x=this.__p.x,this.__y=this.__p.y}static fromScalar(t){const e=t instanceof Uint8Array?B.from(t).toBig():"number"==typeof t?BigInt(t):t,r=qt.mod(e,Dt.N),n=K.BASE.multiply(r);return new Dt(n.x,n.y)}static fromX(t){const e=B.buff(t).toHex();return Dt.from(K.fromHex(e))}static from(t){return new Dt(t.x,t.y)}get p(){return this.__p}get rawX(){const t=this.__p.hasEvenY()?2:3,e=B.big(this.__x);return Uint8Array.of(t,...e)}get rawXR(){const t=this.__p.hasEvenY()?2:3,e=B.big(this.__x);return Uint8Array.of(t,...e)}get rawY(){return B.big(this.__y)}get x(){return this.__x}get y(){return this.__y}eq(t){return t instanceof Dt?this.p.equals(new K(t.x,t.y)):t instanceof Uint8Array?this.x.toString()===t.toString():"number"==typeof t?BigInt(t)===this.x:t===this.x}add(t){return t instanceof Dt?Dt.from(this.p.add(t.p)):Dt.from(this.p.add(Dt.fromScalar(t).p))}sub(t){return t instanceof Dt?Dt.from(this.p.subtract(t.p)):Dt.from(this.p.subtract(Dt.fromScalar(t).p))}mul(t){if(t instanceof Uint8Array){const e=B.from(t).toBig();return Dt.from(this.p.multiply(e))}return t instanceof Dt?Dt.from(this.p.multiply(t.x)):Dt.from(this.p.multiply(t))}};Dt.N=k.n;class Vt{constructor(t){this._secret=B.normalizeBytes(t)}static generate(){return new Vt(B.random(32))}get field(){return new jt(this._secret)}get point(){return this.field.point}get privateKey(){return new Uint8Array(this.field)}get privateHex(){return new B(this.field).toHex()}get publicKey(){return new Uint8Array(this.point.rawX)}get publicHex(){return new B(this.publicKey).toHex()}get xOnlyPub(){return this.publicKey.slice(1,33)}}var Xt=Object.freeze({__proto__:null,Field:jt,Point:Dt,KeyPair:Vt});class Wt extends Vt{constructor(t,e){super(t),this.type=e??"schnorr"}static from(t,e){return new Wt(B.normalizeBytes(t),e)}static generate(){return new Wt(B.random(32))}async sign(t){const e=B.normalizeData(t);return"schnorr"===this.type?Ct.sign(e,this.privateKey):At(e,this.privateKey)}async verify(t,e){const r=B.normalizeData(t),n=B.normalizeBytes(e);return"schnorr"===this.type?Ct.verify(n,r,this.xOnlyPub):St(n,r,this.publicKey)}static async verify(t,e,r,n){n=void 0!==n?n:"schnorr";const i=B.normalizeData(t),o=B.normalizeBytes(e),s=B.normalizeBytes(r);return"schnorr"===n?Ct.verify(s,i,33===(a=o).length?a.slice(1):a):St(s,i,o);var a}}async function Zt(t){return async function(t,e="SHA-256",r=1,n=(t=>t)){let i,o=t.buffer;for(i=0;i<r;i++)o=await crypto.subtle.digest(e,o),n(o);return new Uint8Array(o)}(t,"SHA-256")}const Lt=B.random(32).toBytes(),Jt=B.random(32).toBytes();const Yt=B.random(32).toBytes(),Gt=B.random(32).toBytes();const Mt=new TextEncoder,Qt=B.hex("80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF");o.pointFromScalar(Qt),K.BASE.multiply(BigInt("0x80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF"));const te=jt.fromPrivate(Qt),ee=te.point,re=o.pointFromScalar(Qt,!0);if(null===re)throw TypeError("Encountered null value!");const ne=B.buff(Mt.encode("test"),32),ie=o.sign(ne,te),oe=o.sign(ne,Qt),se=B.num(150,32),ae=te.add(se),ce=o.privateAdd(Qt,se),ue=ee.add(se),fe=o.pointAddScalar(re,se,!0),le=o.pointAddScalar(ee.rawX,se,!0);if(null===ce||null===fe||null===le)throw TypeError("Encountered null value!");const he=o.sign(ne,ae),ye=o.sign(ne,ce);const{Field:de,Point:ge}=Xt,we=new TextEncoder;const{Field:pe,Point:me}=Xt,be=new TextEncoder;const ve=/[\p{Lu}]/u,xe=/[\p{Ll}]/u,Ae=/^[\p{Lu}](?![\p{Lu}])/gu,Ee=/([\p{Alpha}\p{N}_]|$)/u,Se=/[_.\- ]+/,Be=new RegExp("^"+Se.source),Fe=new RegExp(Se.source+Ee.source,"gu"),Ue=new RegExp("\\d+"+Ee.source,"gu");function Ie(t,e){if("string"!=typeof t&&!Array.isArray(t))throw new TypeError("Expected the input to be `string | string[]`");if(e={pascalCase:!1,preserveConsecutiveUppercase:!1,...e},0===(t=Array.isArray(t)?t.map((t=>t.trim())).filter((t=>t.length)).join("-"):t.trim()).length)return"";const r=!1===e.locale?t=>t.toLowerCase():t=>t.toLocaleLowerCase(e.locale),n=!1===e.locale?t=>t.toUpperCase():t=>t.toLocaleUpperCase(e.locale);if(1===t.length)return Se.test(t)?"":e.pascalCase?n(t):r(t);return t!==r(t)&&(t=((t,e,r)=>{let n=!1,i=!1,o=!1;for(let s=0;s<t.length;s++){const a=t[s];n&&ve.test(a)?(t=t.slice(0,s)+"-"+t.slice(s),n=!1,o=i,i=!0,s++):i&&o&&xe.test(a)?(t=t.slice(0,s-1)+"-"+t.slice(s-1),o=i,i=!1,n=!0):(n=e(a)===a&&r(a)!==a,o=i,i=r(a)===a&&e(a)!==a)}return t})(t,r,n)),t=t.replace(Be,""),t=e.preserveConsecutiveUppercase?((t,e)=>(Ae.lastIndex=0,t.replace(Ae,(t=>e(t)))))(t,r):r(t),e.pascalCase&&(t=n(t.charAt(0))+t.slice(1)),((t,e)=>(Fe.lastIndex=0,Ue.lastIndex=0,t.replace(Fe,((t,r)=>e(r))).replace(Ue,(t=>e(t)))))(t,n)}var Pe="@cmdcode/crypto-utils";const He="../src/index.js";let Te;async function Ce(t){Te=t;const e=Ie(String("/"+Pe).split("/").at(-1)),r=await async function(t){if("undefined"!=typeof window)return window[t];const e=process?.argv&&process.argv.length>2?process.argv.slice(2,3):He;if(String(e).includes("main"))throw new Error("Unable to run tests on a commonJs module!");return console.log(`Testing package: ${e}`),import("../"+e).then((t=>t.default?t.default:t))}(e);ke(r)}async function ke(t,e=[]){for(const[r,n]of Object.entries(t))if(U.class(n)){const t=[...e,r];ze(n,t),ke(n,t),console.log("Registering tests for class:",r)}else if(U.function(n))Re(r,n,e);else if(U.object(n)){ke(n,[...e,r])}}async function ze(t,e){const r=[...e,"new"];for(const e of Object.getOwnPropertyNames(t.prototype))Re(e,t,r)}async function Re(t,e,r){const n=`./src/${r.join("/").toLowerCase()}/${t}.test.js`;import(n).then((t=>{for(const r of Object.keys(t))Te.test(n.split("/").at(-1),(n=>{console.log(`Running ${r} tests:\n`),t[r](n,e)}))})).catch((t=>{t.message.includes("Cannot find module")||console.log(`Failed to import test for: ${n}\n${t}`)}))}const{Field:qe,Point:_e}=Xt;t("Crypto-Utils Test Suite",(async t=>{t.test("Cipher Tests",(t=>{!async function(t){t.test("Test encryption/decryption of Cipher suite.",(async t=>{t.plan(3);const e=Vt.generate(),r=Vt.generate(),n=B.random(32).toBytes(),i=await $t.fromShared(e.privateKey,r.publicKey),o=await $t.fromShared(r.privateKey,e.publicKey);t.equal(await i.secretHex,await o.secretHex,"Both secrets should be equal.");const s=await i.encrypt(n),a=await o.encrypt(n);t.notEqual(B.buff(s.slice(0,16)).toHex(),B.buff(a.slice(0,16)).toHex(),"Both IVs should be different.");const c=await i.decrypt(a),u=await o.decrypt(s);t.equal(B.buff(c).toHex(),B.buff(u).toHex(),"Both decrypted payloads should be equal.")}))}(t)})),t.test("Signer Tests",(t=>{!async function(t){t.test("Test signing/validation of Noble library.",(async t=>{const e=qt.isValidPrivateKey(Lt),r=Ct.getPublicKey(Lt),n=pt(Lt,!0),i=await Ct.sign(Jt,Lt),o=await At(Jt,Lt),s=await Ct.verify(i,Jt,r),a=St(o,Jt,n);t.plan(3),t.equal(e,!0,"Private key should be valid."),t.equal(s,!0,"Schnorr signature should be valid."),t.equal(a,!0,"ECDSA signature should be valid.")}))}(t),async function(t){t.test("Test signing/validation of Signer suite.",(async t=>{const e=Wt.from(Yt),r=Wt.from(Yt,"ecdsa"),n=e.publicKey,i=e.xOnlyPub,o=Ct.getPublicKey(Yt),s=r.publicKey,a=pt(Yt,!0),c=await e.sign(Gt),u=await r.sign(Gt),f=await e.verify(Gt,c),l=await r.verify(Gt,u),h=await Wt.verify(Gt,n,c),y=await Wt.verify(Gt,s,u,"ecdsa");t.plan(6),t.deepEqual(i,o,"Schnorr pubkeys should match."),t.deepEqual(s,a,"ECDSA pubkeys should match."),t.equal(f,!0,"Schnorr signature A should be valid."),t.equal(l,!0,"ECDSA signature B should be valid."),t.equal(h,!0,"Schnorr signature C should be valid."),t.equal(y,!0,"ECDSA signature D should be valid.")}))}(t)})),t.test("ECC Tests",(t=>{!function(t){t.test("Testing ECC Primitives",(t=>{t.plan(13),t.deepEqual(new Uint8Array(te),new Uint8Array(Qt),"should be equal seed values"),t.deepEqual(ee.rawX,re,"should be equal points"),t.equal(o.verify(ne,re,ie),!0,"sig1A and K2 should be valid"),t.equal(o.verify(ne,ee.rawX,oe),!0,"sig1B and K1 should be valid"),t.deepEqual(new Uint8Array(ae),new Uint8Array(ce),"our tweaked scalar should match ecc scalar"),t.deepEqual(ue.rawX,fe,"our tweaked point should match ecc point"),t.deepEqual(fe,le,"ecc points should match when tweaking point or scalar"),t.equal(o.verify(ne,ue.rawX,he),!0,"T1 should verify signature 2A"),t.equal(o.verify(ne,fe,he),!0,"T2 should verify signature 2A"),t.equal(o.verify(ne,le,he),!0,"T3 should verify signature 2A"),t.equal(o.verify(ne,ue.rawX,ye),!0,"T1 should verify signature 2B"),t.equal(o.verify(ne,fe,ye),!0,"T2 should verify signature 2B"),t.equal(o.verify(ne,le,ye),!0,"T3 should verify signature 2B")}))}(t),function(t){t.test("Testing ECC Schnorr Signatures",(async t=>{const e=B.random(32),r=e.reverse(),n=new Uint8Array(32);n.set(we.encode("test message"));const i=de.fromPrivate(e),o=ge.from(i.point),s=de.fromPrivate(r),a=ge.from(s.point),c=await Zt(Uint8Array.of(...n,...a.rawX)),u=s.sub(i.mul(c)).point.x,f=a.sub(o.mul(c)).x;t.plan(1),t.equal(u,f,"signature derivations should be equal.")}))}(t),async function(t){t.test("Testing ECC Discrete Log Signatures",(async t=>{const e=new Uint8Array(32),r=new Uint8Array(32);e.set(be.encode("cloudy day")),r.set(be.encode("bitcoin transaction"));const n=pe.fromPrivate(B.random(32)),i=me.from(n.point),o=pe.fromPrivate(B.random(32)),s=me.from(o.point),a=pe.fromPrivate(B.random(32)),c=me.from(a.point),u=await Zt(Uint8Array.of(...e,...s.rawX)),f=await Zt(Uint8Array.of(...r,...c.rawX)),l=s.sub(i.mul(u)),h=o.sub(n.mul(u)),y=a.sub(h.mul(f)),d=c.sub(l.mul(f));t.plan(2),t.equal(h.point.x,l.x,"signature proofs should be equal."),t.equal(y.point.x,d.x,"dlc proofs should be equal.")}))}(t),function(t){t.test("Testing Shared Secret Derivation",(async t=>{const e=qe.fromPrivate(B.random(32)),r=_e.from(e.point),n=qe.fromPrivate(B.random(32)),i=_e.from(n.point).mul(e.num).x,o=r.mul(n.num).x;t.plan(1),t.equal(i,o,"shared secrets should be equal.")}))}(t)})),t.test("API Crawler Tests",(async t=>{await Ce(t)}))}))}(tape,crypto,ecc);
