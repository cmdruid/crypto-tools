!function(t,e,r){"use strict";function n(t){var e=Object.create(null);return t&&Object.keys(t).forEach((function(r){if("default"!==r){var n=Object.getOwnPropertyDescriptor(t,r);Object.defineProperty(e,r,n.get?n:{enumerable:!0,get:function(){return t[r]}})}})),e.default=t,Object.freeze(e)}var o=n(e),i=n(r);const s="qpzry9x8gf2tvdw0s3jn54khce6mua7l",a=[996825010,642813549,513874426,1027748829,705979059],f="bech32",c="bech32m";function u(t){switch(t){case f:return 1;case c:return 734539939;default:throw new Error(`Unrecognized encoding: ${t}`)}}function l(t){let e=1;for(let r=0;r<t.length;++r){const n=e>>25;e=(33554431&e)<<5^t[r];for(let t=0;t<5;++t)(n>>t&1)>0&&(e^=a[t])}return e}function h(t){const e=[];let r;for(r=0;r<t.length;++r)e.push(t.charCodeAt(r)>>5);for(e.push(0),r=0;r<t.length;++r)e.push(31&t.charCodeAt(r));return e}function d(t,e,r,n=!0){const o=[];let i=0,s=0;const a=(1<<r)-1,f=(1<<e+r-1)-1;for(const n of t){if(n<0||n>>e>0)return[];for(i=(i<<e|n)&f,s+=e;s>=r;)s-=r,o.push(i>>s&a)}if(n)s>0&&o.push(i<<r-s&a);else if(s>=e||(i<<r-s&a)>0)return[];return o}function g(t,e,r){const n=e.concat(function(t,e,r){const n=l(h(t).concat(e).concat([0,0,0,0,0,0]))^u(r),o=[];for(let t=0;t<6;++t)o.push(n>>5*(5-t)&31);return o}(t,e,r));let o=t+"1";for(let t=0;t<n.length;++t)o+=s.charAt(n[t]);return o}function w(t,e){const r=e>0?"bech32m":"bech32";if(!function(t){let e,r,n=!1,o=!1;for(e=0;e<t.length;++e){if(r=t.charCodeAt(e),r<33||r>126)return!1;r>=97&&r<=122&&(n=!0),r>=65&&r<=90&&(o=!0)}return!(n&&o)}(t))return{hrp:null,data:[255]};if(!function(t){const e=t.lastIndexOf("1");return!(e<1||e+7>t.length||t.length>90)}(t=t.toLowerCase()))return{hrp:null,data:[255]};const n=[],o=t.lastIndexOf("1"),i=t.substring(0,o);for(let e=o+1;e<t.length;++e){const r=s.indexOf(t.charAt(e));if(-1===r)return{hrp:null,data:[255]};n.push(r)}return function(t,e,r){return l(h(t).concat(e))===u(r)}(i,n,r)?{hrp:i,data:n.slice(0,n.length-6)}:{hrp:null,data:[255]}}function p(t,e=0){const r=t.split("1",1)[0],{hrp:n,data:o}=w(t,e),i=d(o.slice(1),5,8,!1),s=i.length;switch(!0){case r!==n:throw new Error("Returned hrp string is invalid.");case null===i||s<2||s>40:throw new Error("Decoded string is invalid or out of spec.");case o[0]>16:throw new Error("Returned version bit is out of range.");case 0===o[0]&&20!==s&&32!==s:throw new Error("Decoded string does not match version 0 spec.");case 0===o[0]&&0!==e:case 0!==o[0]&&1!==e:throw new Error("Decoded version bit does not match.");default:return Uint8Array.from(i)}}const y={encode:function(t,e="bch",r=0){const n=g(e,[r,...d([...t],8,5)],r>0?"bech32m":"bech32");return p(n,r),n},decode:p};var m=y;const b=[{name:"base58",charset:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"},{name:"base64",charset:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"},{name:"base64url",charset:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"}];function x(t){for(const e of b)if(e.name===t)return e.charset;throw TypeError("Charset does not exist: "+t)}var A={encode:function(t,e,r=!1){const n=x(e),o=n.length,i=[];let s,a,f,c="",u=0;for(s=0;s<t.length;s++)for(u=0,a=t[s],c+=a>0||(c.length^s)>0?"":"1";u in i||a>0;)f=i[u],f=f>0?256*f+a:a,a=f/o|0,i[u]=f%o,u++;for(;u-- >0;)c+=n[i[u]];return r&&c.length%4>0?c+"=".repeat(4-c.length%4):c},decode:function(t,e){const r=x(e),n=r.length,o=[],i=[];t=t.replace("=","");let s,a,f,c=0;for(s=0;s<t.length;s++){if(c=0,a=r.indexOf(t[s]),a<0)throw new Error(`Character range out of bounds: ${a}`);for(s=a>0||(i.length^s)>0?s:i.push(0);c in o||a>0;)f=o[c],f=f>0?f*n+a:a,a=f>>8,o[c]=f%256,c++}for(;c-- >0;)i.push(o[c]);return Uint8Array.from(i)}};class E extends Uint8Array{constructor(t,e=null,r="be"){if(null!==e){const r=new Uint8Array(e).fill(0);r.set(new Uint8Array(t)),t=r.buffer}return super(t="le"===r?new Uint8Array(t).reverse():t),this}toNum(t="le"){return B("le"===t?this.reverse():this)}toBig(t="le"){return U("le"===t?this.reverse():this)}toArr(){return Array.from(this)}toStr(){return F(this)}toHex(){return function(t){const e=[];let r;for(r=0;r<t.length;r++)e.push(t[r].toString(16).padStart(2,"0"));return e.join("")}(this)}toJson(){return JSON.parse(F(this))}toBytes(){return new Uint8Array(this)}toBech32(t,e){return m.encode(this,t,e)}toBase58(){return A.encode(this,"base58")}toBase64(t){return A.encode(this,"base64",t)}toB64url(){return A.encode(this,"base64url")}prepend(t){return E.of(...t,...this)}append(t){return E.of(...this,...t)}slice(t,e){return new E(new Uint8Array(this).slice(t,e))}reverse(){return new E(new Uint8Array(this).reverse())}write(t,e){this.set(t,e)}addVarint(t=this.length){return E.of(...E.getVarint(t),...this)}static from(t){return new E(Uint8Array.from(t))}static of(...t){return new E(Uint8Array.of(...t))}static join(t){let e,r=0;const n=t.reduce(((t,e)=>t+e.length),0),o=new Uint8Array(n);for(const n of t)for(e=0;e<n.length;r++,e++)o[r]=n[e];return new E(o,n)}static getVarint(t){if(t<253)return E.num(t,1);if(t<65536)return E.of(253,...E.num(t,2));if(t<4294967296)return E.of(254,...E.num(t,4));if(t<0x10000000000000000)return E.of(255,...E.num(t,8));throw new Error(`Value is too large: ${t}`)}}function v(t){return(new TextEncoder).encode(t).buffer}function F(t){return(new TextDecoder).decode(t)}function B(t){let e,r=0;for(e=t.length-1;e>=0;e--)r=256*r+t[e];return Number(r)}function U(t){let e,r=0n;for(e=t.length-1;e>=0;e--)r=256n*r+BigInt(t[e]);return BigInt(r)}E.num=(t,e,r="le")=>new E(function(t){const e=[];for(;t>0;){const r=255&t;e.push(r),t=(t-r)/256}return Uint8Array.from(e)}(t),e,r),E.big=(t,e,r="le")=>new E(function(t){const e=[];for(;t>0n;){const r=0xffn&t;e.push(Number(r)),t=(t-r)/256n}return Uint8Array.from(e)}(t),e,r),E.buff=(t,e)=>new E(t,e),E.str=(t,e)=>new E(v(t),e),E.hex=(t,e)=>new E(function(t){const e=[];let r,n=0;if(t.length%2>0)throw new Error(`Invalid hex string length: ${t.length}`);for(r=0;r<t.length;r+=2)e[n]=parseInt(t.slice(r,r+2),16),n+=1;return Uint8Array.from(e).buffer}(t),e),E.json=t=>new E(v(JSON.stringify(t))),E.bech32=(t,e)=>new E(m.decode(t,e)),E.base58=t=>new E(A.decode(t,"base58")),E.base64=t=>new E(A.decode(t,"base64")),E.b64url=t=>new E(A.decode(t,"base64url"));const S={null:t=>null===t,undefined:t=>void 0===t,hex:t=>function(t){switch(!0){case"string"!=typeof t:case/[^0-9a-fA-F]/.test(t):case t.length%2!=0:return!1;default:return!0}}(t),string:t=>"string"==typeof t,infinity:t=>t===1/0,bigint:t=>"bigint"==typeof t,number:t=>"number"==typeof t,class:t=>"object"==typeof t?.prototype&&t.toString().startsWith("class"),function:t=>"function"==typeof t,uint8:t=>t instanceof Uint8Array,uint16:t=>t instanceof Uint16Array,uint32:t=>t instanceof Uint32Array,buffer:t=>t instanceof ArrayBuffer,array:t=>Array.isArray(t),object:t=>"object"==typeof t};var I={of:t=>{for(const[e,r]of Object.entries(S))if(!0===r(t))return e;return"unknown"},array:{isString:t=>t.every((t=>S.string(t))),isNumber:t=>t.every((t=>S.number(t))),isBigint:t=>t.every((t=>S.bigint(t)))},is:S};
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */const T=BigInt(0),P=BigInt(1),_=BigInt(2),C=BigInt(3),H=BigInt(8),N=Object.freeze({a:T,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:P,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")});function R(t){const{a:e,b:r}=N,n=rt(t*t),o=rt(n*t);return rt(o+e*t+r)}const q=N.a===T;class O extends Error{constructor(t){super(t)}}class k{constructor(t,e,r){this.x=t,this.y=e,this.z=r}static fromAffine(t){if(!(t instanceof j))throw new TypeError("JacobianPoint#fromAffine: expected Point");return new k(t.x,t.y,P)}static toAffineBatch(t){const e=function(t,e=N.P){const r=new Array(t.length),n=ot(t.reduce(((t,n,o)=>n===T?t:(r[o]=t,rt(t*n,e))),P),e);return t.reduceRight(((t,n,o)=>n===T?t:(r[o]=rt(t*r[o],e),rt(t*n,e))),n),r}(t.map((t=>t.z)));return t.map(((t,r)=>t.toAffine(e[r])))}static normalizeZ(t){return k.toAffineBatch(t).map(k.fromAffine)}equals(t){if(!(t instanceof k))throw new TypeError("JacobianPoint expected");const{x:e,y:r,z:n}=this,{x:o,y:i,z:s}=t,a=rt(n*n),f=rt(s*s),c=rt(e*f),u=rt(o*a),l=rt(rt(r*s)*f),h=rt(rt(i*n)*a);return c===u&&l===h}negate(){return new k(this.x,rt(-this.y),this.z)}double(){const{x:t,y:e,z:r}=this,n=rt(t*t),o=rt(e*e),i=rt(o*o),s=t+o,a=rt(_*(rt(s*s)-n-i)),f=rt(C*n),c=rt(f*f),u=rt(c-_*a),l=rt(f*(a-u)-H*i),h=rt(_*e*r);return new k(u,l,h)}add(t){if(!(t instanceof k))throw new TypeError("JacobianPoint expected");const{x:e,y:r,z:n}=this,{x:o,y:i,z:s}=t;if(o===T||i===T)return this;if(e===T||r===T)return t;const a=rt(n*n),f=rt(s*s),c=rt(e*f),u=rt(o*a),l=rt(rt(r*s)*f),h=rt(rt(i*n)*a),d=rt(u-c),g=rt(h-l);if(d===T)return g===T?this.double():k.ZERO;const w=rt(d*d),p=rt(d*w),y=rt(c*w),m=rt(g*g-p-_*y),b=rt(g*(y-m)-l*p),x=rt(n*s*d);return new k(m,b,x)}subtract(t){return this.add(t.negate())}multiplyUnsafe(t){const e=k.ZERO;if("bigint"==typeof t&&t===T)return e;let r=et(t);if(r===P)return this;if(!q){let t=e,n=this;for(;r>T;)r&P&&(t=t.add(n)),n=n.double(),r>>=P;return t}let{k1neg:n,k1:o,k2neg:i,k2:s}=at(r),a=e,f=e,c=this;for(;o>T||s>T;)o&P&&(a=a.add(c)),s&P&&(f=f.add(c)),c=c.double(),o>>=P,s>>=P;return n&&(a=a.negate()),i&&(f=f.negate()),f=new k(rt(f.x*N.beta),f.y,f.z),a.add(f)}precomputeWindow(t){const e=q?128/t+1:256/t+1,r=[];let n=this,o=n;for(let i=0;i<e;i++){o=n,r.push(o);for(let e=1;e<2**(t-1);e++)o=o.add(n),r.push(o);n=o.double()}return r}wNAF(t,e){!e&&this.equals(k.BASE)&&(e=j.BASE);const r=e&&e._WINDOW_SIZE||1;if(256%r)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let n=e&&$.get(e);n||(n=this.precomputeWindow(r),e&&1!==r&&(n=k.normalizeZ(n),$.set(e,n)));let o=k.ZERO,i=k.ZERO;const s=1+(q?128/r:256/r),a=2**(r-1),f=BigInt(2**r-1),c=2**r,u=BigInt(r);for(let e=0;e<s;e++){const r=e*a;let s=Number(t&f);if(t>>=u,s>a&&(s-=c,t+=P),0===s){let t=n[r];e%2&&(t=t.negate()),i=i.add(t)}else{let t=n[r+Math.abs(s)-1];s<0&&(t=t.negate()),o=o.add(t)}}return{p:o,f:i}}multiply(t,e){let r,n,o=et(t);if(q){const{k1neg:t,k1:i,k2neg:s,k2:a}=at(o);let{p:f,f:c}=this.wNAF(i,e),{p:u,f:l}=this.wNAF(a,e);t&&(f=f.negate()),s&&(u=u.negate()),u=new k(rt(u.x*N.beta),u.y,u.z),r=f.add(u),n=c.add(l)}else{const{p:t,f:i}=this.wNAF(o,e);r=t,n=i}return k.normalizeZ([r,n])[0]}toAffine(t=ot(this.z)){const{x:e,y:r,z:n}=this,o=t,i=rt(o*o),s=rt(i*o),a=rt(e*i),f=rt(r*s);if(rt(n*o)!==P)throw new Error("invZ was invalid");return new j(a,f)}}k.BASE=new k(N.Gx,N.Gy,P),k.ZERO=new k(T,P,T);const $=new WeakMap;let j=class{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,$.delete(this)}hasEvenY(){return this.y%_===T}static fromCompressedHex(t){const e=32===t.length,r=Q(e?t:t.subarray(1));if(!lt(r))throw new Error("Point is not on curve");let n=function(t){const{P:e}=N,r=BigInt(6),n=BigInt(11),o=BigInt(22),i=BigInt(23),s=BigInt(44),a=BigInt(88),f=t*t*t%e,c=f*f*t%e,u=nt(c,C)*c%e,l=nt(u,C)*c%e,h=nt(l,_)*f%e,d=nt(h,n)*h%e,g=nt(d,o)*d%e,w=nt(g,s)*g%e,p=nt(w,a)*w%e,y=nt(p,s)*g%e,m=nt(y,C)*c%e,b=nt(m,i)*d%e,x=nt(b,r)*f%e;return nt(x,_)}(R(r));const o=(n&P)===P;if(e)o&&(n=rt(-n));else{1==(1&t[0])!==o&&(n=rt(-n))}const i=new j(r,n);return i.assertValidity(),i}static fromUncompressedHex(t){const e=Q(t.subarray(1,33)),r=Q(t.subarray(33,65)),n=new j(e,r);return n.assertValidity(),n}static fromHex(t){const e=tt(t),r=e.length,n=e[0];if(32===r||33===r&&(2===n||3===n))return this.fromCompressedHex(e);if(65===r&&4===n)return this.fromUncompressedHex(e);throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${r}`)}static fromPrivateKey(t){return j.BASE.multiply(ht(t))}static fromSignature(t,e,r){const n=function(t){const{n:e}=N,r=8*t.length-256;let n=Q(t);r>0&&(n>>=BigInt(r));n>=e&&(n-=e);return n}(t=tt(t)),{r:o,s:i}=function(t){if(t instanceof V)return t.assertValidity(),t;try{return V.fromDER(t)}catch(e){return V.fromCompact(t)}}(e);if(0!==r&&1!==r)throw new Error("Cannot recover signature: invalid recovery bit");const s=1&r?"03":"02",a=j.fromHex(s+K(o)),{n:f}=N,c=ot(o,f),u=rt(-n*c,f),l=rt(i*c,f),h=j.BASE.multiplyAndAddUnsafe(a,u,l);if(!h)throw new Error("Cannot recover signature: point at infinify");return h.assertValidity(),h}toRawBytes(t=!1){return M(this.toHex(t))}toHex(t=!1){const e=K(this.x);if(t){return`${this.hasEvenY()?"02":"03"}${e}`}return`04${e}${K(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const t="Point is not on elliptic curve",{x:e,y:r}=this;if(!lt(e)||!lt(r))throw new Error(t);const n=rt(r*r);if(rt(n-R(e))!==T)throw new Error(t)}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new j(this.x,rt(-this.y))}double(){return k.fromAffine(this).double().toAffine()}add(t){return k.fromAffine(this).add(k.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return k.fromAffine(this).multiply(t,this).toAffine()}multiplyAndAddUnsafe(t,e,r){const n=k.fromAffine(this),o=e===T||e===P||this!==j.BASE?n.multiplyUnsafe(e):n.multiply(e),i=k.fromAffine(t).multiplyUnsafe(r),s=o.add(i);return s.equals(k.ZERO)?void 0:s.toAffine()}};function z(t){return Number.parseInt(t[0],16)>=8?"00"+t:t}function D(t){if(t.length<2||2!==t[0])throw new Error(`Invalid signature integer tag: ${Z(t)}`);const e=t[1],r=t.subarray(2,e+2);if(!e||r.length!==e)throw new Error("Invalid signature integer: wrong length");if(0===r[0]&&r[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:Q(r),left:t.subarray(e+2)}}j.BASE=new j(N.Gx,N.Gy),j.ZERO=new j(T,T);class V{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromCompact(t){const e=t instanceof Uint8Array,r="Signature.fromCompact";if("string"!=typeof t&&!e)throw new TypeError(`${r}: Expected string or Uint8Array`);const n=e?Z(t):t;if(128!==n.length)throw new Error(`${r}: Expected 64-byte hex`);return new V(Y(n.slice(0,64)),Y(n.slice(64,128)))}static fromDER(t){const e=t instanceof Uint8Array;if("string"!=typeof t&&!e)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r:r,s:n}=function(t){if(t.length<2||48!=t[0])throw new Error(`Invalid signature tag: ${Z(t)}`);if(t[1]!==t.length-2)throw new Error("Invalid signature: incorrect length");const{data:e,left:r}=D(t.subarray(2)),{data:n,left:o}=D(r);if(o.length)throw new Error(`Invalid signature: left bytes after parsing: ${Z(o)}`);return{r:e,s:n}}(e?t:M(t));return new V(r,n)}static fromHex(t){return this.fromDER(t)}assertValidity(){const{r:t,s:e}=this;if(!ut(t))throw new Error("Invalid Signature: r must be 0 < r < n");if(!ut(e))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const t=N.n>>P;return this.s>t}normalizeS(){return this.hasHighS()?new V(this.r,N.n-this.s):this}toDERRawBytes(t=!1){return M(this.toDERHex(t))}toDERHex(t=!1){const e=z(G(this.s));if(t)return e;const r=z(G(this.r)),n=G(r.length/2),o=G(e.length/2);return`30${G(r.length/2+e.length/2+4)}02${n}${r}02${o}${e}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return M(this.toCompactHex())}toCompactHex(){return K(this.r)+K(this.s)}}function X(...t){if(!t.every((t=>t instanceof Uint8Array)))throw new Error("Uint8Array list expected");if(1===t.length)return t[0];const e=t.reduce(((t,e)=>t+e.length),0),r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const o=t[e];r.set(o,n),n+=o.length}return r}const W=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function Z(t){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");let e="";for(let r=0;r<t.length;r++)e+=W[t[r]];return e}const L=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function K(t){if("bigint"!=typeof t)throw new Error("Expected bigint");if(!(T<=t&&t<L))throw new Error("Expected number < 2^256");return t.toString(16).padStart(64,"0")}function J(t){const e=M(K(t));if(32!==e.length)throw new Error("Error: expected 32 bytes");return e}function G(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function Y(t){if("string"!=typeof t)throw new TypeError("hexToNumber: expected string, got "+typeof t);return BigInt(`0x${t}`)}function M(t){if("string"!=typeof t)throw new TypeError("hexToBytes: expected string, got "+typeof t);if(t.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+t.length);const e=new Uint8Array(t.length/2);for(let r=0;r<e.length;r++){const n=2*r,o=t.slice(n,n+2),i=Number.parseInt(o,16);if(Number.isNaN(i)||i<0)throw new Error("Invalid byte sequence");e[r]=i}return e}function Q(t){return Y(Z(t))}function tt(t){return t instanceof Uint8Array?Uint8Array.from(t):M(t)}function et(t){if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)return BigInt(t);if("bigint"==typeof t&&ut(t))return t;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function rt(t,e=N.P){const r=t%e;return r>=T?r:e+r}function nt(t,e){const{P:r}=N;let n=t;for(;e-- >T;)n*=n,n%=r;return n}function ot(t,e=N.P){if(t===T||e<=T)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let r=rt(t,e),n=e,o=T,i=P;for(;r!==T;){const t=n%r,e=o-i*(n/r);n=r,r=t,o=i,i=e}if(n!==P)throw new Error("invert: does not exist");return rt(o,e)}const it=(t,e)=>(t+e/_)/e,st={a1:BigInt("0x3086d221a7d46bcde86c90e49284eb15"),b1:-P*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),a2:BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),b2:BigInt("0x3086d221a7d46bcde86c90e49284eb15"),POW_2_128:BigInt("0x100000000000000000000000000000000")};function at(t){const{n:e}=N,{a1:r,b1:n,a2:o,b2:i,POW_2_128:s}=st,a=it(i*t,e),f=it(-n*t,e);let c=rt(t-a*r-f*o,e),u=rt(-a*n-f*i,e);const l=c>s,h=u>s;if(l&&(c=e-c),h&&(u=e-u),c>s||u>s)throw new Error("splitScalarEndo: Endomorphism failed, k="+t);return{k1neg:l,k1:c,k2neg:h,k2:u}}let ft,ct;function ut(t){return T<t&&t<N.n}function lt(t){return T<t&&t<N.P}function ht(t){let e;if("bigint"==typeof t)e=t;else if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)e=BigInt(t);else if("string"==typeof t){if(64!==t.length)throw new Error("Expected 32 bytes of private key");e=Y(t)}else{if(!(t instanceof Uint8Array))throw new TypeError("Expected valid private key");if(32!==t.length)throw new Error("Expected 32 bytes of private key");e=Q(t)}if(!ut(e))throw new Error("Expected private key: 0 < key < n");return e}j.BASE._setWindowSize(8);const dt={node:i,web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},gt={},wt={bytesToHex:Z,hexToBytes:M,concatBytes:X,mod:rt,invert:ot,isValidPrivateKey(t){try{return ht(t),!0}catch(t){return!1}},_bigintTo32Bytes:J,_normalizePrivateKey:ht,hashToPrivateKey:t=>{if((t=tt(t)).length<40||t.length>1024)throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");return J(rt(Q(t),N.n-P)+P)},randomBytes:(t=32)=>{if(dt.web)return dt.web.getRandomValues(new Uint8Array(t));if(dt.node){const{randomBytes:e}=dt.node;return Uint8Array.from(e(t))}throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>wt.hashToPrivateKey(wt.randomBytes(40)),sha256:async(...t)=>{if(dt.web){const e=await dt.web.subtle.digest("SHA-256",X(...t));return new Uint8Array(e)}if(dt.node){const{createHash:e}=dt.node,r=e("sha256");return t.forEach((t=>r.update(t))),Uint8Array.from(r.digest())}throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(t,...e)=>{if(dt.web){const r=await dt.web.subtle.importKey("raw",t,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),n=X(...e),o=await dt.web.subtle.sign("HMAC",r,n);return new Uint8Array(o)}if(dt.node){const{createHmac:r}=dt.node,n=r("sha256",t);return e.forEach((t=>n.update(t))),Uint8Array.from(n.digest())}throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(t,...e)=>{let r=gt[t];if(void 0===r){const e=await wt.sha256(Uint8Array.from(t,(t=>t.charCodeAt(0))));r=X(e,e),gt[t]=r}return wt.sha256(r,...e)},taggedHashSync:(t,...e)=>{if("function"!=typeof ft)throw new O("sha256Sync is undefined, you need to set it");let r=gt[t];if(void 0===r){const e=ft(Uint8Array.from(t,(t=>t.charCodeAt(0))));r=X(e,e),gt[t]=r}return ft(r,...e)},precompute(t=8,e=j.BASE){const r=e===j.BASE?e:new j(e.x,e.y);return r._setWindowSize(t),r.multiply(C),r}};function pt(t=32){return r.webcrypto.getRandomValues(new Uint8Array(t))}Object.defineProperties(wt,{sha256Sync:{configurable:!1,get:()=>ft,set(t){ft||(ft=t)}},hmacSha256Sync:{configurable:!1,get:()=>ct,set(t){ct||(ct=t)}}});let yt=class extends Uint8Array{constructor(t){t=t instanceof Uint8Array?E.from(t).toBig():"number"==typeof t?BigInt(t):t,super(t=E.big(yt.mod(t)))}static mod(t,e=yt.N){return wt.mod(t,e)}static fromPrivate(t){if(t<=0)throw new TypeError("Number cannot be negative.");if(t>=yt.N)throw new TypeError("Number cannot be greater than N: 2**256 - 2**32 - 977");return new yt(t)}get num(){const t=new Uint8Array(this);return E.buff(t).toBig()}get point(){return mt.fromScalar(this.num)}gt(t){return new yt(t).num>this.num}lt(t){return new yt(t).num<this.num}eq(t){return new yt(t).num===this.num}ne(t){return new yt(t).num!==this.num}add(t){const e=new yt(t);return new yt(this.num+e.num)}sub(t){const e=new yt(t);return new yt(this.num-e.num)}mul(t){const e=new yt(t);return new yt(this.num*e.num)}pow(t,e=yt.N-1n){const r=new yt(t),n=yt.mod(r.num,e);return new yt(this.num**n)}div(t){const e=new yt(t),r=this.pow(e.num,yt.N-2n);return new yt(this.num*r.num)}};yt.N=N.n,yt.isField=t=>t instanceof yt;let mt=class{constructor(t,e){this.__p=new j(t,e),this.__x=this.__p.x,this.__y=this.__p.y}static fromScalar(t){const e=t instanceof Uint8Array?E.from(t).toBig():"number"==typeof t?BigInt(t):t,r=wt.mod(e,mt.N),n=j.BASE.multiply(r);return new mt(n.x,n.y)}static fromX(t){const e=E.buff(t).toHex();return mt.from(j.fromHex(e))}static from(t){return new mt(t.x,t.y)}get p(){return this.__p}get rawX(){const t=this.__p.hasEvenY()?2:3,e=E.big(this.__x);return Uint8Array.of(t,...e)}get rawXR(){const t=this.__p.hasEvenY()?2:3,e=E.big(this.__x);return Uint8Array.of(t,...e)}get rawY(){return E.big(this.__y)}get x(){return this.__x}get y(){return this.__y}eq(t){return t instanceof mt?this.p.equals(new j(t.x,t.y)):t instanceof Uint8Array?this.x.toString()===t.toString():"number"==typeof t?BigInt(t)===this.x:t===this.x}add(t){return t instanceof mt?mt.from(this.p.add(t.p)):mt.from(this.p.add(mt.fromScalar(t).p))}sub(t){return t instanceof mt?mt.from(this.p.subtract(t.p)):mt.from(this.p.subtract(mt.fromScalar(t).p))}mul(t){if(t instanceof Uint8Array){const e=E.from(t).toBig();return mt.from(this.p.multiply(e))}return t instanceof mt?mt.from(this.p.multiply(t.x)):mt.from(this.p.multiply(t))}};mt.N=N.n;var bt=Object.freeze({__proto__:null,Field:yt,Point:mt});async function xt(t){return async function(t,e="SHA-256",n=1){let o,i=t.buffer;for(o=0;o<n;o++)i=await r.webcrypto.subtle.digest(e,i);return new Uint8Array(i)}(t,"SHA-256")}const At=new TextEncoder,{Field:Et}=bt,vt=E.hex("80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF");o.pointFromScalar(vt),j.BASE.multiply(BigInt("0x80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF80FFFFFF"));const Ft=Et.fromPrivate(vt),Bt=Ft.point,Ut=o.pointFromScalar(vt,!0);if(null===Ut)throw TypeError("Encountered null value!");const St=E.buff(At.encode("test"),32),It=o.sign(St,Ft),Tt=o.sign(St,vt),Pt=E.num(150,32),_t=Ft.add(Pt),Ct=o.privateAdd(vt,Pt),Ht=Bt.add(Pt),Nt=o.pointAddScalar(Ut,Pt,!0),Rt=o.pointAddScalar(Bt.rawX,Pt,!0);if(null===Ct||null===Nt||null===Rt)throw TypeError("Encountered null value!");const qt=o.sign(St,_t),Ot=o.sign(St,Ct);const{Field:kt,Point:$t}=bt,jt=new TextEncoder;const{Field:zt,Point:Dt}=bt,Vt=new TextEncoder;const Xt=/[\p{Lu}]/u,Wt=/[\p{Ll}]/u,Zt=/^[\p{Lu}](?![\p{Lu}])/gu,Lt=/([\p{Alpha}\p{N}_]|$)/u,Kt=/[_.\- ]+/,Jt=new RegExp("^"+Kt.source),Gt=new RegExp(Kt.source+Lt.source,"gu"),Yt=new RegExp("\\d+"+Lt.source,"gu");function Mt(t,e){if("string"!=typeof t&&!Array.isArray(t))throw new TypeError("Expected the input to be `string | string[]`");if(e={pascalCase:!1,preserveConsecutiveUppercase:!1,...e},0===(t=Array.isArray(t)?t.map((t=>t.trim())).filter((t=>t.length)).join("-"):t.trim()).length)return"";const r=!1===e.locale?t=>t.toLowerCase():t=>t.toLocaleLowerCase(e.locale),n=!1===e.locale?t=>t.toUpperCase():t=>t.toLocaleUpperCase(e.locale);if(1===t.length)return Kt.test(t)?"":e.pascalCase?n(t):r(t);return t!==r(t)&&(t=((t,e,r)=>{let n=!1,o=!1,i=!1;for(let s=0;s<t.length;s++){const a=t[s];n&&Xt.test(a)?(t=t.slice(0,s)+"-"+t.slice(s),n=!1,i=o,o=!0,s++):o&&i&&Wt.test(a)?(t=t.slice(0,s-1)+"-"+t.slice(s-1),i=o,o=!1,n=!0):(n=e(a)===a&&r(a)!==a,i=o,o=r(a)===a&&e(a)!==a)}return t})(t,r,n)),t=t.replace(Jt,""),t=e.preserveConsecutiveUppercase?((t,e)=>(Zt.lastIndex=0,t.replace(Zt,(t=>e(t)))))(t,r):r(t),e.pascalCase&&(t=n(t.charAt(0))+t.slice(1)),((t,e)=>(Gt.lastIndex=0,Yt.lastIndex=0,t.replace(Gt,((t,r)=>e(r))).replace(Yt,(t=>e(t)))))(t,n)}var Qt="@cmdcode/crypto-utils";const te="../src/index.js";let ee;async function re(t){ee=t;const e=Mt(String("/"+Qt).split("/").at(-1)),r=await async function(t){if("undefined"!=typeof window)return window[t];const e=process?.argv&&process.argv.length>2?process.argv.slice(2,3):te;if(String(e).includes("main"))throw new Error("Unable to run tests on a commonJs module!");return console.log(`Testing package: ${e}`),import("../"+e).then((t=>t.default?t.default:t))}(e);ne(r)}async function ne(t,e=[]){for(const[r,n]of Object.entries(t))if(I.is.class(n)){const t=[...e,r];oe(n,t),ne(n,t),console.log("Registering tests for class:",r)}else if(I.is.function(n))ie(r,n,e);else if(I.is.object(n)){ne(n,[...e,r])}}async function oe(t,e){const r=[...e,"new"];for(const e of Object.getOwnPropertyNames(t.prototype))ie(e,t,r)}async function ie(t,e,r){const n=`./src/${r.join("/").toLowerCase()}/${t}.test.js`;import(n).then((t=>{for(const r of Object.keys(t))ee.test(n.split("/").at(-1),(n=>{console.log(`Running ${r} tests:\n`),t[r](n,e)}))})).catch((t=>{t.message.includes("Cannot find module")||console.log(`Failed to import test for: ${n}\n${t}`)}))}const{Field:se,Point:ae}=bt;t("Crypto-Utils Test Suite",(async t=>{t.test("ECC Tests",(t=>{!function(t){t.test("Testing ECC Primitives",(t=>{t.plan(13),t.deepEqual(new Uint8Array(Ft),new Uint8Array(vt),"should be equal seed values"),t.deepEqual(Bt.rawX,Ut,"should be equal points"),t.equal(o.verify(St,Ut,It),!0,"sig1A and K2 should be valid"),t.equal(o.verify(St,Bt.rawX,Tt),!0,"sig1B and K1 should be valid"),t.deepEqual(new Uint8Array(_t),new Uint8Array(Ct),"our tweaked scalar should match ecc scalar"),t.deepEqual(Ht.rawX,Nt,"our tweaked point should match ecc point"),t.deepEqual(Nt,Rt,"ecc points should match when tweaking point or scalar"),t.equal(o.verify(St,Ht.rawX,qt),!0,"T1 should verify signature 2A"),t.equal(o.verify(St,Nt,qt),!0,"T2 should verify signature 2A"),t.equal(o.verify(St,Rt,qt),!0,"T3 should verify signature 2A"),t.equal(o.verify(St,Ht.rawX,Ot),!0,"T1 should verify signature 2B"),t.equal(o.verify(St,Nt,Ot),!0,"T2 should verify signature 2B"),t.equal(o.verify(St,Rt,Ot),!0,"T3 should verify signature 2B")}))}(t),function(t){t.test("Testing ECC Schnorr Signatures",(async t=>{const e=E.hex("3ddd5602285899a946114506157c7997e5444528f3003f6134712147db19b678").toBytes(),r=e.reverse(),n=new Uint8Array(32);n.set(jt.encode("test message"));const o=kt.fromPrivate(e),i=$t.from(o.point),s=kt.fromPrivate(r),a=$t.from(s.point),f=await xt(Uint8Array.of(...n,...a.rawX)),c=s.sub(o.mul(f)).point.x,u=a.sub(i.mul(f)).x;t.plan(1),t.equal(c,u,"signature derivations should be equal.")}))}(t),async function(t){t.test("Testing ECC Discrete Log Signatures",(async t=>{const e=new Uint8Array(32),r=new Uint8Array(32);e.set(Vt.encode("cloudy day")),r.set(Vt.encode("bitcoin transaction"));const n=zt.fromPrivate(pt(32)),o=Dt.from(n.point),i=zt.fromPrivate(pt(32)),s=Dt.from(i.point),a=zt.fromPrivate(pt(32)),f=Dt.from(a.point),c=await xt(Uint8Array.of(...e,...s.rawX)),u=await xt(Uint8Array.of(...r,...f.rawX)),l=s.sub(o.mul(c)),h=i.sub(n.mul(c)),d=a.sub(h.mul(u)),g=f.sub(l.mul(u));t.plan(2),t.equal(h.point.x,l.x,"signature proofs should be equal."),t.equal(d.point.x,g.x,"dlc proofs should be equal.")}))}(t),function(t){t.test("Testing Shared Secret Derivation",(async t=>{const e=se.fromPrivate(pt(32)),r=ae.from(e.point),n=se.fromPrivate(pt(32)),o=ae.from(n.point),i=r.mul(n.num).x,s=o.mul(e.num).x;t.plan(1),t.equal(i,s,"shared secrets should be equal.")}))}(t)})),t.test("API Crawler Tests",(async t=>{await re(t)}))}))}(tape,ecc,crypto);
